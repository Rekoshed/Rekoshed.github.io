
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width">
		<title>Командная сторока</title>
		  <link  href="../../Design/script.css" rel="stylesheet">
		  <link  href="../../Design/toolbar.css" rel="stylesheet">
		  <script src ="../../Design/bild.js"></script>
		  </head>
     <body>
	     <script>
	 		toolbar('../../index.html','../Bash_main.html');
		 </script>
			<div class="content">

				<p>Тема пользователей и их прав в системе в первую очередь относится к функционированию самой операционной системы. Оболочка лишь предоставляет утилиты, позволяющие анализировать доступы и изменять их.</p>

<p>Взаимодействие с операционной системой всегда ведётся от какого-то конкретного пользователя, созданного в системе. Команда <code>whoami</code> позволяет выяснить, кто же я такой:</p>

<pre><code class="sh">$ whoami
kirill.m
</code></pre>

<p>Абсолютно любой процесс, запускаемый в операционной системе, стартует от имени некоторого пользователя. Соответственно, его возможности по влиянию на файловую систему ограничены теми правами, которые есть у пользователя, от имени которого процесс запущен. Обратите внимание на то, что я говорю не "пользователь запустил процесс", а "процесс запускается от имени пользователя". Дело в том, что присутствие пользователя для запуска необязательно. Да, работая в командной строке мы стартуем всё сами, но когда система загружается, то она стартует множество различных процессов и, как мы увидим ниже, для многих из них создаются собственные пользователи с ограниченным набором прав.</p>

<p>Команда <code>ps</code> (<strong>p</strong>rocess <strong>s</strong>tatus) выводит отчёт о работающих процессах. Информацию о том, какой процесс и под каким пользователем запущен, можно получить из вывода <code>ps aux</code>:</p>

<pre><code class="sh">$ ps aux
# Левый столбец имя пользователя
root      7717  0.0  0.0   4244  1504 ?        S    10:52   0:00 mpstat 1 3
kirill.m  7718  0.0  0.1  36084  3236 pts/0    R+   10:52   0:00 ps aux
alexand+ 10542  0.0  0.1  21500  2892 pts/1    Ss+  10:10   0:00 -bash
root     11113  0.0  0.1  92796  2596 ?        Ss   08:50   0:00 sshd: kirill.m [priv]
kirill.m 11116  0.0  0.0  45276  1408 ?        Ss   08:50   0:00 /lib/systemd/systemd --user
kirill.m 11119  0.0  0.0  61148  1860 ?        S    08:50   0:00 (sd-pam)
kirill.m 11194  0.0  0.0  92796  1800 ?        S    08:50   0:00 sshd: <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="6e05071c07020240032e1e1a1d">[email&#160;protected]</a>/0
kirill.m 11195  0.0  0.2  21388  4448 pts/0    Ss   08:50   0:00 -bash
root     12195  0.0  0.0      0     0 ?        S    10:13   0:00 [kworker/u30:1]
root     12880  0.0  0.1  92796  2748 ?        Ss   08:55   0:00 sshd: alexander.v [priv]
alexand+ 12883  0.0  0.0  45276  1924 ?        Ss   08:55   0:00 /lib/systemd/systemd --user
alexand+ 12884  0.0  0.0  61148  1860 ?        S    08:55   0:00 (sd-pam)
alexand+ 12920  0.0  0.1  92796  2420 ?        S    08:55   0:00 sshd: <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="c6a7aaa3bea7a8a2a3b4e8b086b6b2b5">[email&#160;protected]</a>/1,pts/2
</code></pre>

<p>Взаимодействие с файловой системой происходит через запуск тех или иных утилит, модифицирующих, создающих или анализирующих файловую структуру. Это значит, что запуская, например, <code>touch</code>, мы стартуем процесс от своего имени, внутри которого запускается программа <code>touch</code>. Она, в свою очередь, создаёт файл (если его не было) и делает вас владельцем нового файла. Кстати, модификация существующих файлов не влияет на владельца — для его смены нужно воспользоваться специальной утилитой. В домашней директории пользователя всё принадлежит пользователю (хотя, если постараться, то можно навертеть как угодно):</p>

<pre><code class="sh">$ ls -la
total 44
drwxr-xr-x 5 kirill.m kirill.m 4096 Aug 29 11:34 .
drwxr-xr-x 8 root     root     4096 Apr 26 10:38 ..
-rw------- 1 kirill.m kirill.m 2540 Aug 30 07:26 .bash_history
-rw-r--r-- 1 kirill.m kirill.m  220 Aug 31  2015 .bash_logout
-rw-r--r-- 1 kirill.m kirill.m 3771 Aug 31  2015 .bashrc
drwx------ 2 kirill.m kirill.m 4096 Mar 30 18:10 .cache
-rw------- 1 kirill.m kirill.m   55 Aug 28 18:49 .lesshst
drwxrwxr-x 2 kirill.m kirill.m 4096 Aug 29 08:35 .nano
-rw-r--r-- 1 kirill.m kirill.m  655 May 16  2017 .profile
-rw-rw-r-- 1 kirill.m kirill.m    0 Aug 29 11:27 renamed-file
drwx------ 2 kirill.m kirill.m 4096 Jan 22  2018 .ssh
-rw------- 1 kirill.m kirill.m  513 Aug 29 08:06 .viminfo
</code></pre>

<p>Третий столбец в этом выводе — как раз владелец. Единственная запись, которая выбивается из всего списка это <code>..</code>, то есть родительская директория. Её владельцем является <code>root</code>, о котором мы позже поговорим. Если хорошо подумать, то это логично — ведь директория <code>/home</code> не является собственностью пользователей системы:</p>

<pre><code class="sh">$ ls -la /home/
total 32
drwxr-xr-x  8 root              root              4096 Apr 26 10:38 .
drwxr-xr-x 23 root              root              4096 Aug 27 06:53 ..
drwxr-xr-x  5 alexander.v       alexander.v       4096 Jan 22  2018 alexander.v
drwxr-xr-x  5 kirill.m          kirill.m          4096 Aug 29 11:34 kirill.m
drwxr-xr-x  4 rakhim            rakhim            4096 Apr 26 10:05 rakhim
drwxr-xr-x  4 rakhim.d          rakhim.d          4096 Apr 26 10:41 rakhim.d
</code></pre>

<p>Каждый каталог в директории <code>/home</code> является домашним каталогом конкретного пользователя. Поэтому они все имеют разных владельцев, как правило, совпадающих с именем директории.</p>

<p>Имя пользователя в системе должно быть уникальным, но его можно менять. Если посмотреть под капот работы этой системы, то мы увидим, что имя пользователя связано с идентификатором, называемым UID. Это число, которое и определяет пользователя. Если поменяется имя пользователя, но идентификатор останется прежним, то все доступы останутся. Если же сменится идентификатор, то фактически сменится и пользователь. Соответственно, новый пользователь потеряет доступы ко всему старому. Посмотреть свой идентификатор можно разными способами. Первый способ — с помощью команды <code>id</code>:</p>

<pre><code class="sh">$ id
uid=1002(kirill.m) gid=1002(kirill.m) groups=1002(kirill.m),999(docker)
</code></pre>

<p>Второй способ связан с просмотром одного важного файла, который является основным хранилищем пользователей в *nix системах. Да, это обычный текстовый файл, как и всё остальное.</p>

<pre><code class="sh">$ cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/usr/sbin/nologin
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
mail:x:8:8:mail:/var/mail:/usr/sbin/nologin
news:x:9:9:news:/var/spool/news:/usr/sbin/nologin
uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin
proxy:x:13:13:proxy:/bin:/usr/sbin/nologin
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
kirill.m:x:1002:1002::/home/kirill.m:/bin/bash
</code></pre>

<p><img src="https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjUyODI0OWRlNTQxZTBhNjNiNmJjNGI2NjAzNGE1YjU5LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=1d57a0c5562f36fcf786605431445682b36fee3456bf5a1c9e3a72a5b090b898" alt="Схема записей в файле /ect/passwd"></p>

<p>Кроме имени и идентификатора, здесь также указана домашняя директория пользователя (и её можно поменять), а так же шелл по умолчанию. Запись <code>/usr/sbin/nologin</code> говорит о том, что данный пользователь не может входить в систему. Такие пользователи нужны для запуска программ, имеющих ограниченные права, и им, естественно, не нужно входить в систему.</p>

<p>Кроме имени, у пользователей *nix систем есть связанное с ним понятие группа. Группа, как можно догадаться из названия, создана для группового доступа к разделяемому (общему) ресурсу (например, файлу). Например, у нас есть группа разработчиков, которые регулярно ходят на сервер, и им нужно дать одинаковые возможности по управлению определёнными файлами. Так как владелец у файла ровно один, то мы не можем решить этот вопрос через смену владельца, но можем через создание группы. Достаточно её создать и привязать к самому пользователю. Группы, ассоциированные с текущим пользователем, показываются в выводе команды <code>id</code>:</p>

<pre><code class="sh">$ id
uid=1002(kirill.m) gid=1002(kirill.m) groups=1002(kirill.m),999(docker)
</code></pre>

<p>Здесь группа <code>kirill.m</code> является основной, такая группа может быть только одна, и именно в эту группу входят любые создаваемые файлы от имени текущего пользователя. Кроме основной, пользователь может входить в произвольное число дополнительных групп. То, как это влияет на доступы, мы рассмотрим в одном из следующих уроков.</p>

<p>В любой *nix системе присутствует специальный пользователь <code>root</code>, или, как говорят, суперпользователь. Главная его особенность — это идентификатор со значением 0 (а имя в теории можно поменять). Этот пользователь имеет особое значение для системы и может выполнять абсолютно любые действия в системе. У пользователя <code>root</code> в файле <code>/etc/passwd</code> будет вот такая запись:</p>

<p><img src="https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjUxYjIwNmYzNTNmN2I0NDllNjU1N2FmMGIxZGY3OTkzLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=d2ca368f197cd4f98df8d69e8abd3cdb0ac426390bfebcf4db18bf7ea80b23ca" alt="Схема записей в /ect/passwd польлзователя root"></p>

<p>Крайне не рекомендуется использовать этого пользователя на регулярной основе. И ни в коем случае нельзя входить под ним в систему. root — это прямой доступ ко всему и большая дыра в безопасности системы. Кроме того, систему очень легко убить, например, удалив случайно не тот файл или испортив важную конфигурацию, после чего вход в систему станет невозможным.</p>

<p>Несмотря на это, <code>root</code> нужен для выполнения некоторых привилегированных действий, которые недоступны обычным пользователям. Об этом мы поговорим в следующем уроке.</p>


<p>Ситуаций, в которых необходимо повышать привилегии и выполнять команды от рута (пользователя <code>root</code>), довольно много. С некоторыми мы уже столкнулись, с другими познакомимся в следующих уроках:</p>

<ul>
<li>Установка новых программ</li>
<li>Навигация по чужим директориям</li>
<li>Изменение прав доступа и владельцев файлов, не принадлежащих текущему пользователю</li>
<li>Создание, редактирование и удаление файлов в местах, где не хватает прав текущего пользователя</li>
<li>Запуск программ, требующих повышенные привилегии</li>
</ul>

<p>Стать другим пользователем, находясь прямо в системе, можно с помощью утилиты <code>su</code> (<strong>s</strong>ubstitute <strong>u</strong>ser, <strong>s</strong>witch <strong>u</strong>ser). Когда-то такой способ был основным, но сейчас он устарел и крайне не рекомендуется к использованию. Подробнее об этом можно прочитать в статье из дополнительных материалов. Основной способ повышать привилегии в современных системах — утилита <code>sudo</code> (<strong>s</strong>ubstitute <strong>u</strong>ser and <strong>do</strong> — дословно "подменить пользователя и выполнить").</p>

<p>Используется судо очень просто, достаточно поставить её слева от любой команды и выполнить. По умолчанию она пытается повысить привилегии до суперпользователя:</p>

<pre><code class="sh"># Нет прав на выполнение
$ touch /etc/myfile
touch: cannot touch '/etc/myfile': Permission denied

# С sudo все работает
$ sudo touch /etc/myfile

# Видно что владелец файла root
$ stat /etc/myfile
  File: '/etc/myfile'
  Size: 0           Blocks: 0          IO Block: 4096   regular empty file
Device: ca01h/51713d    Inode: 2761        Links: 1
Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)

# Нет прав на удаление
$ rm /etc/myfile
rm: remove write-protected regular empty file '/etc/myfile'? y
rm: cannot remove '/etc/myfile': Permission denied

# Опять помогло sudo
$ sudo rm /etc/myfile
$
</code></pre>

<p>В зависимости от настроек <code>sudo</code> в системе, эта утилита может попросить ваш пароль для входа, либо вообще откажется работать, сказав, что у вас нет права её использовать. Как правило, в Ubuntu судо спрашивает пароль и запоминает его на 5 минут. На протяжении этого времени вы можете использовать <code>sudo</code>, не вводя пароль каждый раз.</p>

<p>Иногда бывает нужно выполнить команду из под пользователя, отличного от <code>root</code>. Тогда придётся добавить флаг <code>-u</code>:</p>

<pre><code class="sh">$ sudo -u nobody mkdir /tmp/test
# Файл создан от nobody
$ stat /tmp/test
  File: '/tmp/test'
  Size: 4096        Blocks: 8          IO Block: 4096   directory
Device: ca01h/51713d    Inode: 4577        Links: 2
Access: (0755/drwxr-xr-x)  Uid: (65534/  nobody)   Gid: (65534/ nogroup)
</code></pre>

<p>Если стоит задача произвести сразу пачку действий от имени другого пользователя, то для этого можно запустить новую сессию поверх текущей:</p>

<pre><code class="sh">$ sudo -i
$ id
uid=0(root) gid=0(root) groups=0(root)
</code></pre>

<p>Главное — не забыть переключиться обратно после завершения необходимых манипуляций. Для этого наберите <code>exit</code>.</p>

<p>Частая ошибка, с которой встречаются разработчики — ошибка доступа:</p>

<pre><code class="sh">$ touch /etc/myfile
touch: cannot touch '/etc/myfile': Permission denied
</code></pre>

<p>Она говорит о том, что текущий пользователь не имеет прав на создание файлов в каталоге <code>/etc</code>. Почему? Давайте разбираться.</p>

<p>Кроме имени пользователя и группы, с каждым файлом ассоциированы права доступа: <strong>r</strong> — чтение, <strong>w</strong> — запись и <strong>x</strong> — исполнение. Причём, эти права задаются для трёх типов пользователей: владельца (Owner), пользователей, входящих в ту же группу (Group) и остальных (Other) — тех, кто не попал в предыдущие две. Разберём на примере:</p>

<pre><code class="sh"># Пример строчки из вывода команды ls -la
-rw-r--r-- 1 kirill.m kirill.m 3771 Aug 31  2015 .bashrc
</code></pre>

<p>Запись слева представляет из себя один из вариантов описания прав доступа (permissions). Для удобства чтения разделим эту запись на группы символов <code>- rw- r-- r--</code>. Символ <code>-</code> в этой записи говорит о том, что перед нами обычный файл. За ним следует три группы, в каждой из которых по три символа. Каждая группа описывает доступы для разных типов пользователей. Первая описывает права доступа для владельца файла. <code>rw-</code> означает, что владелец этого файла может как читать (r) этот файл, так и писать (w) в него. Последний прочерк означает, что этот файл нельзя исполнять. Исполнение описывается символом <code>x</code> и будет рассмотрено в следующем уроке. Не важно, какой файл или директорию мы смотрим — порядок прав в этой группе всегда один и тот же <code>чтение-запись-исполнение</code>, а прочерк означает отсутствие данного права.</p>

<p>Следующая группа прав относится к тем, кто входит в группу <code>kirill.m</code>, так как именно этой группе принадлежит данный файл. Запись <code>r--</code> говорит о наличии доступа только для чтения, а изменение запрещено. То же самое касается и тех, кто не входит в эту группу, то есть набор прав у последних двух одинаковый.</p>

<p><img src="https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImNkZWI3ZmIzMGJiZmM5MDYzMDk0MTYwOGViZTcyMTQ2LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=3964690f815de89cce96cf9db326caf4579136fa8ff767858d9c4b4e58c0e6bb" alt="File Permissions"></p>

<p>Попробуйте ответить на вопрос с подвохом: а кто может удалить этот файл? Для ответа на этот вопрос важно знать владельца, группу и права той директории, в которой лежит файл <code>.bashrc</code>. Сам файл не может обозначить прав на своё удаление, они всегда берутся из того места, где он находится. Удалить файл можно только, если у вас есть возможность писать в эту директорию (в соответствии с тем, к какому типу пользователей вы относитесь).</p>

<pre><code class="sh">$ ls -la /home/ | grep kirill
drwxr-xr-x  5 kirill.m          kirill.m          4096 Aug 29 11:34 kirill.m
</code></pre>

<script id="asciicast-E3Nn9bBAHhRvVoy5VKPBOMgde" src="https://asciinema.org/a/E3Nn9bBAHhRvVoy5VKPBOMgde.js" data-cols="120" data-rows="12" data-preload="1" async></script>

<p>Домашняя директория имеет другие права. Первое отличие — это <code>d</code> вместо <code>-</code> в самом начале. <code>d</code> говорит о том, что перед нами директория. Права для владельца <code>rwx</code>, а для всех остальных <code>r-x</code>. Из этого описания видно, что кроме пользователя никто не может писать внутрь домашней директории этого пользователя.</p>

<p>Что такое <code>x</code> в отношении директорий? Это право позволяет перемещаться в директорию и обращаться ко всем расположенным в ней файлам и каталогам. Обращаться можно при условии, что эти файлы доступны на чтение или запись или выполнение: например, если положить доступный на чтение файл в директорию с правом <code>x</code>, то вы сможете прочитать этот файл. Если же убрать с директории право <code>x</code>, то вы вовсе лишитесь доступа к файлу.</p>

<p>Но что тогда такое чтение? Здесь всё более интуитивно понятно: директория, по сути, является списком файлов, поэтому право на чтение позволяет прочитать этот список файлов, а именно вывести список имён файлов, содержащихся в директории. Однако, если хотите посмотреть не простой список имён файлов, а список с дополнительной информацией (как при выводе <code>ls -l</code>), то требуется ещё и право <code>x</code>, потому что в этом случае надо обращаться к файлам за их метаданными (владелец, группа, дата изменения, права и др.). В любом случае, без права <code>r</code> на каталог вы не сможете посмотреть его содержимое.</p>

<p>В литературе (статьях, книгах, мануалах) иногда используется другой способ описания прав доступа: <code>775</code>. Это не одно число, а три числа, каждое из которых представляет собой группу <code>rwx</code> для наших типов пользователя в том же порядке: для владельца, входящих в группу и всех остальных. <code>0</code> — означает, что нет никаких прав для данного типа пользователей.</p>

<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>#</td>
<td>Permission</td>
<td>rwx</td>
<td>Binary</td>
</tr>
<tr>
<td>2</td>
<td>7</td>
<td>read, write and execute</td>
<td>rwx</td>
<td>111</td>
</tr>
<tr>
<td>3</td>
<td>6</td>
<td>read and write</td>
<td>rw-</td>
<td>110</td>
</tr>
<tr>
<td>4</td>
<td>5</td>
<td>read and execute</td>
<td>r-x</td>
<td>101</td>
</tr>
<tr>
<td>5</td>
<td>4</td>
<td>read only</td>
<td>r--</td>
<td>100</td>
</tr>
<tr>
<td>6</td>
<td>3</td>
<td>write and execute</td>
<td>-wx</td>
<td>011</td>
</tr>
<tr>
<td>7</td>
<td>2</td>
<td>write only</td>
<td>-w-</td>
<td>010</td>
</tr>
<tr>
<td>8</td>
<td>1</td>
<td>execute only</td>
<td>--x</td>
<td>001</td>
</tr>
</tbody>
</table>

<p><code>drwxr-xr-x</code> в числовой форме соответствует <code>755</code>, а <code>-rw-r--r--</code> — <code>644</code>.</p>

<p>Однако пользователь <code>root</code> находится вне этой системы. Для него не имеет никакого значения наличие любых прав — рут может всё.</p>

            </div>
  </div>
 </body>
</html>