
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width">
		<title>Командная сторока</title>
		  <link  href="../../Design/script.css" rel="stylesheet">
		  <link  href="../../Design/toolbar.css" rel="stylesheet">
		  <script src ="../../Design/bild.js"></script>
		  </head>
     <body>
	     <script>
	 		toolbar('../../index.html','../Bash_main.html');
		 </script>
			<div class="content">

				<html><body>
                <h3> Перенаправление потоков </h3>
                    <p>В каждом языке есть собственный способ напечатать результат на экран:</p>
                    
                    <p><strong>javascript</strong></p>
                    
                    <pre class="kod">console.log('hello!');
                    </pre>
                    
                    <p><strong>php</strong></p>
                    
                    <pre class="kod">&lt;?php
                    
echo 'hello!';
                    </pre>
                    
                    <p><strong>python</strong></p>
                    
                    <pre class="kod">print('hello!')
        </pre>
                    
                    <p><strong>java</strong></p>
                    
                    <pre class="kod">System.out.print("hello!");
                    </pre>
                    
                    <p><strong>ruby</strong></p>
                    
                    <pre class="kod">puts 'hello!'
                </pre>
                    
                    <p>Несмотря на разнообразие языков и способов печати, с точки зрения операционной системы, которая запускает программу, все они работают абсолютно идентично. При старте любой программы операционная система связывает с ней три так называемых потока: <strong>STDIN</strong> (Standard Input), <strong>STDOUT</strong> (Standard Output) и STDERR (Standard Error). Для языка программирования они выглядят как файлы, и взаимодействие с ними происходит как с файлами. STDOUT как раз отвечает за вывод на экран. Каждый раз, когда в программе (на любом языке) происходит печать на экран, функция печати, на самом деле, записывает с помощью функции <code>write</code> данные в STDOUT, а вот уже операционная система решает куда вывести результат. По умолчанию вывод происходит на экран терминала.</p>
                    
                    <p><em>Здесь нужно сказать, что хорошее понимание этой темы требует знания устройства операционных систем, в частности подсистемы отвечающей за процессы и файловую систему. В двух словах, никакой язык программирования не может знать про существование экрана, а уж тем более не может с ним взаимодействовать. Ответственность за взаимодействие с железом целиком и полностью лежит на плечах операционной системы, а программы могут только лишь попросить операционную систему выполнить ту или иную задачу. При таком разделении реализация языков программирования сильно упрощается. Достаточно знать про существование STDOUT и уметь писать в него, а дальше всё сделает операционная система. Это значит, что программа, написанная на одном компьютере, без проблем запустится на другом с другой конфигурацией и монитором (или даже без монитора).</em></p>
                    
                    <p>Самое удивительное начинается дальше. ОС позволяет подменять эти потоки при старте системы, что открывает интересные возможности. Например, вывод любой команды, запущенной в баше, можно записать в файл вместо вывода на экран.</p>
                    
                    <pre class="cmd">$ ls -la &gt; output
                    </pre>
                    
                    <p>Запустив эту команду, вы увидите, что на экране ничего не отобразилось, но в текущей директории появился файл <code>output</code>.</p>
                    
                    <pre class="cmd">$ cat output
total 58
rwx------  2 rekoshed rekoshed   4096 Jul 25 11:03 .some
drwxrwxr-x 21 rekoshed rekoshed   4096 Sep  1 01:58 Some.Disk
drwxr-xr-x  2 rekoshed rekoshed   4096 Jul 14 09:25 Видео
drwxr-xr-x  2 rekoshed rekoshed   4096 Jul 14 09:25 Документы
drwxr-xr-x  2 rekoshed rekoshed   4096 Sep 27 09:17 Загрузки
drwxr-xr-x  2 rekoshed rekoshed   4096 Jul 27 08:12 Изображения
drwxr-xr-x  2 rekoshed rekoshed   4096 Jul 14 09:25 Музыка
drwxr-xr-x  2 rekoshed rekoshed   4096 Jul 14 09:25 Общедоступные
drwxr-xr-x  2 rekoshed rekoshed   4096 Jul 14 09:25 Шаблоны

                    </pre>
                    
                    <p>Операция, которую мы сделали выше, называется <strong>перенаправление потоков</strong>. Символ <code>&gt;</code> означает, что нужно взять вывод из команды, указанной слева, и отправить его в файл, указанный справа. <code>&gt;</code> всегда <strong>перезаписывает</strong> файл. Такое перенаправление работает с абсолютно любой командой, которая выводит результаты своей работы на экран.</p>
                    
                    <pre class="cmd">$ grep alias .bash_profile &gt; result
                    $ cat result
                    alias fixssh='eval $(tmux showenv -s SSH_AUTH_SOCK)'
                    </pre>
                    
                    <p>Если нужно не перезаписывать, а <strong>добавлять</strong>, то используйте <code>&gt;&gt;</code>.</p>
                    
                    <p>Для экспериментов с выводом удобно использовать встроенную в шел команду <code>echo</code>. Она принимает на вход строчку и выдаёт её в STDOUT, который уже можно перенаправлять.</p>
                    
                    <pre class="cmd"># &gt; перетирает файл
                    $ echo 'hello' &gt; result
                    $ cat result
                    hello
                    $ echo 'hello' &gt; result
                    $ cat result
                    hello
                    # &gt;&gt; добавляет содержимое в конец файла
                    $ echo 'hello' &gt;&gt; result
                    $ cat result
                    hello
                    hello
                    $
                    </pre>
                    
                    <p>Кроме стандартного вывода, с каждым процессом ассоциируются два дополнительных потока: один STDIN (стандартный ввод) и STDERR (вывод ошибок). STDIN работает в обратную сторону: через него программа может получать данные на вход. В *nix системах встроена утилита <code>wc</code>
                    (word count — "количество слов"), которая умеет считать количество слов, строк или символов в файле. Когда мы говорим о файле, то в *nix это почти всегда означает, что данные можно передать и в стандартный поток ввода.</p>
                    
                    <pre class="cmd"># Флаг l (l а не 1) говорит о том, что надо считать количество строк
                    $ wc -l &lt; result
                    2
                    </pre>
                    
                    <p>Выглядит довольно логично — стрелка меняет своё направление в другую сторону и содержимое файла отправляется в STDIN запускаемой программы <code>wc</code>. Теперь сделаем финт и объединим перенаправление ввода и вывода.</p>
                    
                    <pre class="cmd">$ wc -l &lt; result &gt; output
                    $ cat output
                    $ 2
                    </pre>
                    
                    <p>Кстати, таким же способом можно отправить вывод на печать, но оставлю эту возможность на самостоятельное изучение.</p>
                    
                    
                    <p>Последний вопрос связан с тем, зачем нужен STDERR. Он, как и STDOUT, по умолчанию идёт на экран. STDERR позволяет отделить нормальный вывод программы от возникающих ошибок. Такой подход удобен при ведении логов, для реагирования и отладки. Будьте осторожны, перенаправление вывода в файл перенаправляет только STDOUT. Убедиться в этом очень просто. Если попробовать перейти в несуществующую директорию, то команда <code>cd</code> выдаст ошибку:</p>
                    
                    <pre class="cmd">$ cd lala
                    -bash: cd: lala: No such file or directory
                    </pre>
                    
                    <p>Теперь попробуем перенаправить вывод в файл <code>output</code></p>
                    
                    <pre class="cmd">$ cd lala &gt; output
                    -bash: cd: lala: No such file or directory
                    </pre>
                    
                    <p>Перенаправление есть, но сообщение вывелось на экран. Это произошло именно по той причине, что STDERR остался привязан к  экрану, а внутри файла <code>output</code> — пустота. Решить эту задачу можно двумя способами. Перенаправив STDERR в STDOUT, либо отправив их оба в файл.</p>
                    
                    <p><strong>Перенаправление STDERR в STDOUT</strong></p>
                    
                    <pre class="cmd"># Сначала STDERR перенаправляется в STDOUT, затем STDOUT в файл
                    $ cd lala &gt; output 2&gt;&amp;1
                    $ cat output
                    -bash: cd: lala: No such file or directory
                    </pre>
                    
                    <p>2 - в данном случае обозначает номер потока. В POSIX, за каждым потоком закреплен определенный номер, который является <a href="https://ru.wikipedia.org/wiki/%D0%A4%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2%D1%8B%D0%B9_%D0%B4%D0%B5%D1%81%D0%BA%D1%80%D0%B8%D0%BF%D1%82%D0%BE%D1%80" target="_blank">файловым дескриптором</a> если быть точным: STDIN — 0, STDOUT — 1, STDERR — 2. Конструкцию <code>2&gt;&amp;1</code> нужно просто запомнить, она говорит о том, что поток с номером 2 отправляем в поток с номером 1</p>
                    
                    <p>Перенаправление STDERR бывает полезно само по себе, без вывода в файл.</p>
                    
                    <pre class="cmd">#  STDERR просто перенаправляется в другой поток (STDOUT)
                    $ cd lala 2&gt;&amp;1
                    -bash: cd: lala: No such file or directory
                    </pre>
                    
                    <p><strong>Перенаправление обоих потоков в файл</strong></p>
                    
                    <pre class="cmd"># Сначала STDERR перенаправляется в STDOUT, затем STDOUT в файл
                    $ cd lala &amp;&gt; output
                    $ cat output
                    -bash: cd: lala: No such file or directory
                    </pre>
    <h3> Пайплайн </h3>
                    <p>Раз у одного процесса есть вход, а у другого — выход, и их можно подменять, то логично предположить, что их можно соединить. Данный подход носит название <strong>pipeline</strong> (конвейер). Благодаря пайплайну можно соединять программы и протаскивать данные сквозь них, как сквозь цепочку функций, каждая из которых выступает в роли преобразователя или фильтра.</p>

<p>Когда мы грепали, то делали это по какому-то одному слову, но часто возникает задача грепать по нескольким словам. Не важно, как они расположены внутри строки, главное, что они встречаются там вместе. Такую функциональность можно было бы сделать, усложнив саму программу <code>grep</code>. Но пайплайн позволяет добиться такого же поведения без необходимости писать сложную программу.</p>

<pre class="cmd">$ grep alias .bashrc | grep color
# enable color support of ls and also add handy aliases
alias ls='ls --color=auto'
#alias dir='dir --color=auto'
#alias vdir='vdir --color=auto'
alias grep='grep --color=auto'
alias fgrep='fgrep --color=auto'
alias egrep='egrep --color=auto'
</pre>

<p><code>|</code> — этот символ называется <strong>пайп</strong>, он указывает шелу взять STDOUT одного процесса и соединяет его с STDIN другого процесса. Поскольку grep принимает на вход текст (как я говорил в прошлом уроке, все утилиты, которые читают файлы, могут принимать данные через STDIN) и возвращает текст, то его можно комбинировать бесконечно.</p>

<p>Запись <code>grep alias .bashrc | grep color</code> можно изменить, используя перенаправление. Так она станет проще для модификации:</p>

<pre class="kod">$ cat .bashrc | grep alias | grep color
</pre>

<p>В примере выше файл читается катом и отправляется в STDIN грепа.</p>

<p>Ещё один пример:</p>
<pre id ='cmd'>
~$ cat source                                                                                                           
Snoop Dog                                                                                                               
Doggy cupcakes                                                                                                          
Tom cat                                                                                                                 
Reservoir Dogs                                                                                                          
Jerry mouse                                                                                                             
Dog                                                                                                                     
Dog                                                                                                                     
~$                                                                                                                      
~$ cat source | grep Dog | uniq | sort                                                                                  
Dog                                                                                                                     
Doggy cupcakes                                                                                                          
Reservoir Dogs                                                                                                          
Snoop Dog                                                                                                               
~$             
</pre>
<p class="kod">cat source | grep Dog | uniq | sort
</p>

<ol>
<li>Читается файл source</li>
<li>Входные данные грепаются по подстроке "Dog"</li>
<li>Убираются дубли (в исходном файле две одинаковых строки "Dog")</li>
<li>Входные данные сортируются и выводятся на экран</li>
</ol>

<p>Пайплайн стал основой Unix философии, которая звучит так:</p>

<ul>
<li>Пишите программы, которые делают что-то одно и делают это хорошо.</li>
<li>Пишите программы, которые бы работали вместе.</li>
<li>Пишите программы, которые бы поддерживали текстовые потоки, поскольку это универсальный интерфейс.</li>
</ul>

<p>Именно поэтому большинство утилит работают с сырым текстом — принимают его на вход и возвращают в STDOUT. Такой подход позволяет получать сложное поведение из крайне простых составных блоков. Такая концепция называется стандартные интерфейсы и хорошо отражена в конструкторах Lego.</p>
            </div>

  </div>
 </body>
</html>