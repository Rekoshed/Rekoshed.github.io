
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width">
		<title>Phyton обзор</title>
		  <link  href="../../Design/script.css" rel="stylesheet">
		  <link  href="../../Design/toolbar.css" rel="stylesheet">
		  <script src ="../../Design/bild.js"></script>
		  </head>
     <body>
	     <script>
	 		toolbar('../../index.html','../Bash_main.html');
		 </script>
			<div class="content">
                    <p>Файловая структура *nix систем серьёзно отличается от структуры в Windows и заслуживает отдельного внимания. Начнём с базовых понятий. Файловая структура представляет собой <strong>дерево</strong>, в <em>узлах</em> которого находятся <strong>директории</strong>, а в <em>листьях</em> — <strong>файлы</strong>.</p>

                    <p>Кстати, понятие "папка" в *nix системах не используется, говорят "директория" или "каталог", хотя по существу эти термины означают одно и тоже.</p>
                    
                    <p><img src="https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjE4NTJiMjE2NzlmMmJkMzI5Zjg3MjY2ZmJiNDU4Y2YxLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=5604c95f6827d105b7aec0804052463565422d8f878540c9bdb5c784e6fa5f01" alt="Unix Filetree"></p>
                    
                    <p>В Windows файловая структура представлена не одним, а несколькими деревьями, так как каждая структура находится на своём диске. В *nix системах — единственное дерево с корнем в <code>/</code>. Все устройства, физические и логические диски находятся внутри этого дерева в виде директорий и файлов.</p>
                    
                    <p>Информация о любом файле или директории доступна по команде <code>stat</code> (file system <strong>stat</strong>us):</p>
                    
                    <pre><code class="sh"># Не обращайте внимание на непонятные для вас данные, об их значении поговорим позже
                    $ stat .bashrc
                      File: '.bashrc'
                      Size: 3771        Blocks: 8          IO Block: 4096   regular file
                    Device: ca01h/51713d    Inode: 259234      Links: 1
                    Access: (0644/-rw-r--r--)  Uid: ( 1002/kirill.m)   Gid: ( 1002/kirill.m)
                    Access: 2018-08-27 17:24:11.237498138 +0000
                    Modify: 2015-08-31 23:27:45.000000000 +0000
                    Change: 2018-01-22 08:13:27.611966864 +0000
                     Birth: -
                    </code></pre>
                    
                    <script id="asciicast-evHx3Dudt2TZIJlkI38OmZpEv" src="https://asciinema.org/a/evHx3Dudt2TZIJlkI38OmZpEv.js" data-cols="120" data-rows="15" data-preload="1" async></script>
                    
                    <p>В Windows мы привыкли, что имя файла может быть набрано в разных регистрах, и это всегда один и тот же файл, то есть имена регистронезависимы. В *nix системах регистр имеет значение. Файлы <code>index.html</code>, <code>Index.html</code>, <code>INDEX.HTML</code> и <code>index.HTML</code> — это разные файлы. Всегда обращайте внимание на регистр, потому что ошибиться довольно легко.</p>
                    
                    <p><em>MacOS в этой ситуации идет по пути Windows и тоже не учитывает регистр</em></p>
                    
                    <p>Говорят, что в *nix "всё есть файл". На нижнем уровне так и есть (почти). Директория — это специальный файл, который содержит список файлов. Любое подключаемое устройство становится файлом или директорией, если это накопитель. Такая концепция довольно удобна для разработчиков, потому что печать на принтер и вывод на экран между собой ничем не отличаются — для кода это просто "запись в файл". На пользовательском уровне директория всё же отличается от файла и имеет собственные команды для создания, удаления и модификации.</p>
                    
                    <p>В *nix системах есть базовый набор каталогов, который стандартизирован (FHS). За каждым закреплена какая-то особая роль. Например, каталог <code>/etc</code> содержит конфигурацию программ в обычных текстовых файлах (в юниксах нет реестра, вся конфигурация лежит в обычных файлах), а каталог <code>/home</code> содержит домашние директории пользователей системы (исключением является суперпользователь <code>root</code>, его домашний каталог обычно находится по адресу <code>/root</code>). Обязательно пробегитесь по странице <a href="https://ru.wikipedia.org/wiki/FHS" target="_blank">https://ru.wikipedia.org/wiki/FHS</a> и посмотрите, что за что отвечает.</p>
                    
                    <p>Не во все директории можно заходить, не все файлы можно читать или менять, и не все программы можно запускать. В *nix системах развитая система прав, завязанная на пользователей и группы. О ней мы поговорим отдельно позже. Сейчас достаточно знать, что такие ограничения есть. Их можно увидеть в выводе команды <code>ls -l</code>.</p>
                    
                    <p>В отличие от Windows, в *nix системах отсутствует понятие "расширение файла". Точка — полноправная часть имени. Это не значит, что в юниксах невозможно понять тип файла. Это возможно, более того, файлы почти всегда именуются так же, как и в Windows, например <strong>hello.mp3</strong>, но важно понимать, что вся эта строчка — имя файла. Нередко встречаются и такие имена: <code>index.html.haml</code>. В *nix также есть скрытые файлы, но, в отличие от Windows, это не свойство файла, а определённое имя файла. Все файлы и директории, начинающиеся с точки, считаются скрытыми. Вывести все файлы, включая скрытые, можно командой <code>ls -a</code>:</p>
                    
                    <pre><code class="sh">$ ls -a
                    .  ..  .bash_history  .bash_logout  .bashrc  .cache  .profile  .ssh
                    </code></pre>
                    
                    <p>Обратите внимание на две особые директории, обозначенные "точкой" (<code>.</code>) и "двумя точками" (<code>..</code>). Точка означает текущую директорию, а две точки — директорию верхнего уровня. Именно благодаря этой схеме работает команда <code>cd ..</code>, которая перемещает нас на уровень выше.</p>
                    
                    <p>Кроме регулярных файлов, в *nix существует ряд других:</p>
                    
                    <ul>
                    <li>
                    <strong>Hard Link</strong> — дополнительное имя для уже существующего файла.</li>
                    <li>
                    <strong>Symbolic link</strong> — символическая ссылка, такой файл похож на ярлык в Windows. Если удалить основной файл, то символическая ссылка начнёт вести в никуда.</li>
                    <li>
                    <strong>Socket</strong> — специальный файл через который происходит взаимодействие между разными процессами операционной системы. Программисты постоянно сталкиваются с сокетами в реальной жизни.</li>
                    </ul>
                    
                    <p>Это наиболее важные на начальном этапе знакомства с файловой системой типы файлов. Есть ещё и другие типы, но не будем сейчас заострять на них внимание.</p>

                    

                    <p>Теперь, когда мы понимаем общее устройство файловой системы в POSIX совместимых ОС, пора приступать к взаимодействию с файлами. В этом уроке рассмотрим различные способы чтения текстовых файлов.</p>

<p>Самый простой способ прочитать файл — команда <code>cat</code>.</p>

<pre><code class="sh">$ man cat

NAME
     cat -- concatenate and print files

SYNOPSIS
     cat [-benstuv] [file ...]

...
</code></pre>

<p><code>cat</code> ожидает аргументы — пути до файлов, которые надо читать. В простейшем случае достаточно передать один путь, это довольно удобно, когда надо посмотреть содержимое небольшого файла:</p>

<pre><code class="sh">$ cat .bash_logout
# ~/.bash_logout: executed by bash(1) when login shell exits.

# when leaving the console clear the screen to increase privacy

if [ "$SHLVL" = 1 ]; then
    [ -x /usr/bin/clear_console ] &amp;&amp; /usr/bin/clear_console -q
fi
</code></pre>

<script id="asciicast-IbARaXrklWFR6sWgNwaPlMKf2" src="https://asciinema.org/a/IbARaXrklWFR6sWgNwaPlMKf2.js" data-cols="120" data-rows="13" data-preload="1" async></script>

<p>Иногда бывает нужно посмотреть только начало файла или его конец, в такой ситуации помогают команды <code>head</code> и <code>tail</code>. Они тоже принимают на вход путь до файла, только <code>head</code> показывает первые 10 строк, а <code>tail</code> — последние 10 строк файла. Это поведение можно менять, задавая желаемое количество строк через опцию <code>-n</code>.</p>

<p><strong>Head</strong></p>

<pre><code class="sh">$ head -n 2 .bashrc
# ~/.bashrc: executed by bash(1) for non-login shells.
# see /usr/share/doc/bash/examples/startup-files (in the package bash-doc)
</code></pre>

<p><strong>Tail</strong></p>

<pre><code class="sh">$ tail -n 2 .bashrc
  fi
fi
</code></pre>

<script id="asciicast-H9CQaHmULiG1OhAFfzm4lKqTX" src="https://asciinema.org/a/H9CQaHmULiG1OhAFfzm4lKqTX.js" data-cols="120" data-rows="15" data-preload="1" async></script>

<p>Некоторые файлы наполняются очень интенсивно. Например, так называемые "логи". Логи (иногда говорят "журналы") — это текстовые файлы, в которые заносится информация о происходящих процессах в определённой системе. В Linux логи лежат в каталоге <code>/var/log</code>. Туда пишет как сам Linux, так и большая часть установленных программ. Основной файл логов Linux называется <code>syslog</code>. Туда попадает ключевая информация о происходящих процессах в операционной системе и возникающих ошибках. Если события происходят часто и есть потребность анализировать их в процессе поступления, то команда <code>cat</code> оказывается неудобной, потому что <code>syslog</code> большой. Не подходит и простой запуск команды <code>tail</code>, потому что придётся запускать её каждую секунду и всё равно можно что-нибудь пропустить (если интенсивность записи событий в лог очень высокая).</p>

<p>В этой ситуации поможет <code>tail</code>, запущенный в особом режиме благодаря флагу <code>-f</code>. <code>tail -f path/to/file</code> не просто выводит последние строчки файла, но ждёт появления новых. Как только файл дописывается, <code>tail</code> сразу выводит на экран добавленные строки. Среди наших примеров это первая команда, которая захватывает управление, то есть после запуска она не заканчивает выполнение сразу, а продолжает работать, ожидая новые данные в файле, который выводится. Для остановки её выполнения нажмите <kbd>Ctrl + C</kbd>.</p>

<pre><code class="sh"># Вероятно у вас не хватит прав смотреть файл syslog, чтобы получить к нему доступ,
# наберите sudo перед командой tail как показано ниже, в следующих уроках этот вопрос рассматривается подробнее
# Есть вероятность того что sudo попросить вас ввести пароль. Сделайте это и нажмите Enter. При наборе пароля
# курсор не будет двигаться, это сделано для безопасности.
$ sudo tail -f syslog
Aug 28 18:00:01 ip-10-0-1-223 systemd-udevd[15400]: Could not generate persistent MAC address for veth5c6ed9c: No such file or directory
Aug 28 18:00:01 ip-10-0-1-223 kernel: [126412.013499] device veth6969122 entered promiscuous mode
Aug 28 18:00:01 ip-10-0-1-223 systemd[1]: Starting Update resolvconf for networkd DNS...
Aug 28 18:00:01 ip-10-0-1-223 systemd-timesyncd[522]: Network configuration changed, trying to establish connection.
Aug 28 18:00:01 ip-10-0-1-223 systemd-timesyncd[522]: Synchronized to time server 91.173.73.198:123 (ntp.ubuntu.com).
Aug 28 18:00:01 ip-10-0-1-223 sh[15415]: sed: cant read /run/systemd/netif/leases/*: No such file or directory
Aug 28 18:00:01 ip-10-0-1-223 kernel: [126412.086162] IPv6: ADDRCONF(NETDEV_UP): veth6969122: link is not ready
Aug 28 18:00:01 ip-10-0-1-223 systemd-udevd[15403]: Could not generate persistent MAC address for veth6969122: No such file or directory
Aug 28 18:00:02 ip-10-0-1-223 systemd-timesyncd[522]: Network configuration changed, trying to establish connection.
Aug 28 18:00:02 ip-10-0-1-223 systemd-timesyncd[522]: Synchronized to time server 91.173.73.198:123 (ntp.ubuntu.com).
Aug 28 18:00:02 ip-10-0-1-223 systemd-timesyncd[522]: Network configuration changed, trying to establish connection.
</code></pre>

<p>Особая категория программ для просмотра содержимого файла — <strong>пейджеры</strong>. Пейджер похож на текстовый редактор, но открытый только в режиме чтения. Самый распространённый пейджер называется <code>less</code>. Попробуем открыть с помощью него файл <code>syslog</code>:</p>

<pre><code class="sh"># Снова придется воспользоваться sudo
$ sudo less syslog
# здесь много вывода
</code></pre>

<p><code>less</code> открывает файл и остаётся в этом режиме. Он позволяет перемещаться по файлу вперёд и назад, производить поиск. Одна из отличительных особенностей пейджеров состоит в том, что они одинаково хорошо и быстро работают с файлами любых размеров. Всё потому, что пейджер не пытается загрузить в память весь файл до его отображения. Он грузит только ту часть, которая помещается на экран и при перемещении подгружает остальное.</p>

<p><code>less</code> предоставляет несколько десятков команд для перемещения по тексту и его поиску, про большинство из них можно прочитать в соответствующем мануале. Здесь же затронем основные:</p>

<ul>
<li>
<code>q</code> — выход</li>
<li>
<code>f</code> — вперёд на страницу</li>
<li>
<code>b</code> — назад на страницу</li>
<li>если набрать <code>/</code>, затем начать вводить буквы и нажать <kbd>Enter</kbd>, то выполнится поиск введённого текста. Перемещение по найденным совпадениям выполняется командой <code>n</code> (переход к следующему совпадению) и командой <code>N</code> (переход к предыдущему совпадению).</li>
</ul>

<p>Возможно, вы увидели сходство поведения пейджеров с тем, что мы наблюдали в мануалах. Открою секрет: когда мы запускали <code>man</code>, то перед нами открывался <code>less</code> с загруженным туда контентом. Как вы увидите позже, пейджеры невероятно популярны и неявно запускаются другими программами.</p>

				
            </div>
  </div>
 </body>
</html>