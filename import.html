
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width">
		<title>Phyton обзор</title>
		<link  href="../../Design/script.css" rel="stylesheet">
		<link  href="../../Design/toolbar.css" rel="stylesheet">
		<script src ="../../Design/bild.js"></script>
		</head>
	<body>
	<script>
	toolbar('../../index.html','../PyMain.html');
	</script>
	<div class="content">
          
            <p>В этом конспекте , да и не только, будет встречаться словосочетание "через точку". Так часто говорят для краткости. 
            Но для такой формы записи имён определений (<code>module.name</code>) 
            существует и официальный термин: <em>квалифицированное имя</em> от слова "квалифицировать" ("qualify"). 
            Соответственно, "импорт модуля целиком"  официально называется <em>квалифицированным импортом</em>.</p>
            
            <p>В Python все строчки с <code>import</code> принято располагать в самом начале кода модуля. 
                Такой набор строчек называют "блок импортов", 
                синтаксически этот блок никак не выделен — всего лишь обычные строчки одна за другой.
                Такая группировка нужна для удобства ра
          
            <h3>Модули и импортирование</h3>
            
            <p>файл с кодом на Python называется <em>модулем</em>. Имя модуля соответствует имени файла, 
                поэтому файлы в Python принято называть в стиле "snake_case". Одни модули могут использовать содержимое других,
                 если <em>импортируют</em> эти другие модули с помощью инструкции <code>import</code>.</p>
            
            <p>В Python импортировать модули можно несколькими способами:</p>
            
            <ol>
            <li>импортировать сам модуль</li>
            <li>импортировать отдельные определения из модуля</li>
            <li>импортировать всё содержимое модуля сразу</li>
            </ol>
            
            <h3>Импортирование модуля</h3>
            
            <p>Рассмотрим применение первого способа — импортирование модуля целиком. </p>
            
            <p>Синтаксис импорта: <code>import &lt;имя_модуля (без суффикса ".py")&gt;</code></p>
            
            <p>После ключевого слова <code>import</code> указываем имя модуля (файла). 
            Но при этом суффикс <code>.py</code> в имени надо опустить.
            К примеру, для модуля с именем <code>my_module.py</code> в инструкции импорта достаточно прописать <code>my_module</code>,
             а полный вид инструкции будет таким: <code>import my_module</code>.</p>
            
            <p>В модуле (файле) с именем <em>greeting.py</em> определим функцию <code>say_hi</code> и переменную <code>name</code>:</p>
            
            <pre><code class="python"># file: greeting.py
            def say_hi():
                print('Hi!')
            
            name = 'Bob'
            </code></pre>
            
            <p>А в модуле с именем <em>main.py</em> сделаем импорт содержимого модуля <em>greeting.py</em>:</p>
            
            <pre><code class="python"># file: main.py
            import greeting  # заметьте, расширение ".py" не указывается!
            
            print(greeting.name)  # =&gt; Bob
            greeting.say_hi()     # =&gt; Hi!
            </code></pre>
            
            <p>Импортирование модуля в таком виде делает модуль доступным по имени — в данном случае это <code>greeting</code>. 
            К содержимому же модуля идёт обращение, как говорят, "через точку". 
            И конечно можно получить доступ к переменным (<code>greeting.name</code>), 
             и вызывать функции модуля (<code>greeting.say_hi</code>).</p>
            
            <h3>Импортирование отдельных определений</h3>
            
            <p>Синтаксис импорта: <code>from &lt;имя_модуля (без суффикса ".py")&gt; import &lt;список определений&gt;</code>.</p>
            
            <p>Если нужна пара функций или переменных,
             а имя модуля сложное и громозкое, то нам пригодиться следующий вариант использования инструкции <code>import</code>:</p>
            
            <pre><code class="python"># file: main.py
            from greeting import say_hi, name
            
            print(name)  # используем переменную
            say_hi()     # вызываем функцию
            </code></pre>
            
            <p>Здесь после ключевого слова <code>from</code> указано имя модуля,
                 а затем после ключевого слова <code>import</code> — имена определений из этого модуля,
                  которые мы в дальнейшем будем использовать напрямую (а не "через точку").</p>
            
                 
                  <h3>Импорт всего содержимого модуля</h3>
                  
                  <p>Ранее мы познакомились с модулями и рассмотрели два из трёх вариантов импортирования — импорт самого модуля и импорт отдельных определений. Рассмотрим оставшийся вариант — импортирование всего содержимого модуля. Пример:</p>
                  
                  <pre><code class="python">from some_module import *
                  from another_module import *
                  </code></pre>
                  
                  <p>Здесь из модулей <code>some_module</code> и <code>another_module</code> импортируются все определения неявно. Часто после такого импорта программисту становятся доступны десятки переменных, констант, функций и тому подобного. В этом-то и кроется проблема! Когда ниже по коду программист, читающий этот код, встречает некое имя, то ему бывает очень сложно понять, откуда это имя взялось — нельзя, просто взглянув на блок импортов, найти источник. Поиск по коду модуля тоже не помогает — все имена определений, импортированных данным способом, скрываются за <code>*</code>!</p>
                  
                  <p>Большинство руководств по написанию хорошего кода на Python крайне не рекомендует использовать такой стиль импортирования. Однако в реальном коде такие импорты встречаются, поэтому мы не могли этот вариант не упомянуть.</p>
                  
                  <h3>Сочетание способов импортирования</h3>
                  
                  <p>Импортирование модуля целиком (т.е. квалифицированное) и импортирование отдельных определений могут сочетаться даже применительно к одному и тому же модулю!</p>
                  
                  <p>Давайте рассмотрим пример.</p>
                  
                  <p>В модуле <code>computation.py</code> определим функцию и переменные:</p>
                  
                  <pre><code class="python"># file: computation.py
                  PI = 3.1415926
                  E = 2.7182818
                  
                  def pi_times(x):
                      return x + PI
                  </code></pre>
                  
                  <p>А в модуле <code>main.py</code> сделаем разными способами импорты из модуля <code>computation.py</code>:</p>
                  
                  <pre><code class="python"># file: main.py
                  import computation
                  from computation import PI, E
                  from computation import pi_times
                  
                  print(PI)
                  print(computation.E)
                  print(pi_times(2))
                  print(computation.pi_times(E))
                  </code></pre>
                  
                  <p>Из кода видно, что:</p>
                  
                  <ul>
                  <li>оба способа импорта использованы совместно,</li>
                  <li>импортировать отдельные определения можно в несколько заходов,</li>
                  <li>если модуль импортирован по имени, то "через точку" можно получить доступ и к тем определениям, которые уже явно импортированы.</li>
                  </ul>
    </div>
  </div>
 </body>
</html>