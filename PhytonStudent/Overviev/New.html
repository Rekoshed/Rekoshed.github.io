
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width">
		<title>Phyton обзор</title>
		  <link  href="../../Design/script.css" rel="stylesheet">
		  <link  href="../../Design/toolbar.css" rel="stylesheet">
		  <script src ="../../Design/bild.js"></script>
		  </head>
     <body>
	     <script>
	 		toolbar('../../index.html','../PyMain.html');
		 </script>
			<div class="content">
	   
				<h3>Знакомсьво с REPL</h3>

<p>Python поставляется со встроенным REPL. REPL – это программа, которая по сути выполняет код python  в интерактивном режиме. 
	. Акроним REPL расшифровывается так:</p>

<ul>
<li>Read — прочитать ввод от пользователя,</li>
<li>Eval — выполнить введённый код,</li>
<li>Print — распечатать на экран результат,</li>
<li>Loop — снова войти в режим ожидания.</li>
</ul>

<p>Для запуска REPL достаточно набрать <code>python3</code>:</p>

<script id="asciicast-p2zsV8lGTzWteiIVHRL5vlJWb" src="https://asciinema.org/a/p2zsV8lGTzWteiIVHRL5vlJWb.js" data-cols="80" data-rows="4" data-size="medium" data-preload="1" async></script>

<p>Теперь можно выполнять код на Python и сразу же смотреть на результат его выполнения. Наберите любой корректный код на Python, например такой:</p>

<script id="asciicast-g09J00gAlt5jwvOUbjVzNtV4Z" src="https://asciinema.org/a/g09J00gAlt5jwvOUbjVzNtV4Z.js" data-cols="80" data-rows="4" data-size="medium" data-preload="1" async></script>

<p>REPL выводит результат выполнения операции прямо на экран и снова входит в режим ожидания ввода команд. Для выхода из REPL нужно вместо ввода кода нажать <kbd>Ctrl + D</kbd>.</p>

<p>Такой способ работы очень хорошо подходит для быстрой проверки гипотез "а как работает эта штука?", а также для отладки и простых вычислений. Пример работы с REPL:</p>

<script id="asciicast-244341" src="https://asciinema.org/a/244341.js" data-cols="80" data-rows="6" data-size="medium" data-preload="1" async></script>

<h3>Встроенная документация</h3>

<p>Язык Python прямо на уровне синтаксиса поддерживает дополнение кода документацией. Основным средством документирования являются так называемые "<em>строки документации</em>" ("<em>docstrings</em>"). Документированная функция выглядит так:</p>

<pre><code class="python">def add(x, y):
    """Add one argument to another."""
    return x + y
</code></pre>

<p>Из таких docstrings генерируется online-документация. А ещё эта документация доступна для просмотра прямо в REPL! Для просмотра документации служит функция <code>help</code>. Давайте объявим функцию add в REPL, попробуем её вызвать, а затем посмотрим описание нашей функции и нескольких встроенных:</p>

<script id="asciicast-251502" src="https://asciinema.org/a/251502.js" data-cols="80" data-rows="20" data-size="medium" data-preload="1" async></script>

<p>Даже просто быстро узнать, что делает та или иная функция — очень полезно. Но функция <code>help</code> может работать и в интерактивном режиме: если её вызвать без аргументов (<code>help()</code>), то будет показана страница приветствия и приглашение в строке ввода изменится на <code>help&gt;</code>. Страница приглашения показывает, какие команды можно вводить, а
также упоминает, что для выхода из режима справки нужно дать команду <code>quit</code> (нажатие <kbd>Ctrl+D</kbd> вместо ввода команды тоже сработает). Новичкам может быть полезна команда <code>topics</code>, выводящая список тем, по которым можно почитать статьи прямо в этом же режиме справки REPL'а. Войдём же в режим справки, выведем список тем, а затем откроем статью, которая рассказывает о доступных в языке Python операторах:</p>

<script id="asciicast-251506" src="https://asciinema.org/a/251506.js" data-cols="80" data-rows="20" data-size="medium" data-preload="1" async></script>

<h3>REPL и примеры кода в источниках.</h3>

<p>REPL в Python-мире настолько широко используется, что в самых разных источниках — статьях, книгах, документации к библиотекам — можно встретить примеры, изображающие кусочек "диалога" программиста и REPL. Выглядит это примерно так:</p>

<pre><code class="python">&gt;&gt;&gt; 1 + 2
3
&gt;&gt;&gt; len("Thomas")
5
&gt;&gt;&gt; "Hello" + '\n' + "World!"
'Hello\nWorld!'
&gt;&gt;&gt; print("Hello" + '\n' + "World!")
Hello
World!
</code></pre>

<p>Здесь строчки, начинающиеся на <code>&gt;&gt;&gt;</code> (эти символы называются "приглашением" ("prompt")) — это код, введённый программистом. А следующий за "вводом" текст до следующей строчки с приглашением, представляет собой результат выполнения введённого кода. Если вы решите попробовать указанный в таком виде пример самостоятельно, не вводите само приглашение, вводите только сам код, следующий за символами <code>&gt;&gt;&gt;</code>. И строки вывода тоже вводить не нужно — тут уж интерпретатор сам справится!</p>

<p>Привыкайте к этому формату публикации примеров, в наших курсах он тоже будет использоваться широко!</p>

<h3>Каноническое представление и вывод на печать</h3>

<p>Заметьте, что при вводе строки, в выводе интерпретатора оная отображается с кавычками и со спецсимволами. Числа выводятся, как числа. То же самое касается вывода любых других значений: большинство значений выводится в виде <em>"канонического строкового представления" ("canonical string representation")</em>. Представленные таким образом значения, как правило, можно скопировать в строку приглашения и выполнить опять, т.е. <em>каноническое представление</em> обычно <em>является правильным кодом на Python</em>.</p>

<blockquote>
<p>Кстати, самостоятельно получить каноническое представление произвольного значения можно с помощью функции <code>repr</code>. Примеры:</p>
</blockquote>

<pre><code class="python">&gt;&gt;&gt; repr(42)
'42'
&gt;&gt;&gt; repr("foo")
'"foo"'
&gt;&gt;&gt; repr(None)
'None'
</code></pre>

<p>А вот результат вызова функции <code>print</code> не содержит кавычек, и спецсимволы, вроде символа переноса строки, не отображаются (но эффект на вывод оказывают). Так происходит, как вы могли догадаться, потому, что мы видим результат <em>вывода строки на печать</em>.</p>

<h3>REPL и None</h3>

<p>Ещё вам стоит знать о том, как REPL отображает возврат из функции значения <code>None</code>. Дело в том, что никак! Это сделано специально: любая функция, которая не возвращает результат явно, считается функцией, возвращающей <code>None</code>. И чтобы не "мозолить глаза" программисту бесконечными None в выводе REPL, авторами интерпретатора было решено подавлять вывод этого значения. Именно поэтому в примере выше REPL мы не увидели, что функция <code>print</code> на самом деле вернула <code>None</code>! Но мы всё же можем увидеть в REPL <code>None</code>, если обернём вызов <code>print</code>... в ещё один вызов <code>print</code>:</p>

<pre><code class="python">&gt;&gt;&gt; print(42)
42
&gt;&gt;&gt; print(print(42))
42
None
</code></pre>

<p>Вот и оно, значение <code>None</code>! Мы видим это значение потому, что второй <code>print</code> получает <code>None</code> на вход и приводит к строке, а уже строку — печатает.</p>

<p>Если вы вдруг столкнётесь с ситуацией, когда ваша функция в REPL вызывается, но "ничего не возвращается" — не паникуйте! Возможно ваша функция всего лишь возвращает <code>None</code> (скажем, потому, что вы забыли сделать <code>return</code>)!</p>

<h3>Ввод многострочного кода</h3>

<p>В Python REPL можно вводить и многострочный код, а ведь не каждый REPL такое позволяет! И пусть отредактировать уже введённые строчки не получится, но, к примеру, небольшие функции вводить вполне удобно. Когда вы вводите строчку, которая по смыслу ещё не завершилась, то REPL меняет приглашение на <code>...</code> и ожидает ввода новой строчки в дополнение к уже введённой. Так можно ввести целое определение функции вместе с docstring и логикой. Окончанием ввода всего многострочного кода служит пустая строчка (поэтому в коде не получится использовать пустые строчки). В источниках примеры с многострочным кодом будут выглядеть так:</p>

<pre><code class="python">&gt;&gt;&gt; def is_positive(x):
...     """Return True if argument is positive."""
...     if x &lt;= 0:
...          return False
...     return True
...
&gt;&gt;&gt; is_positive(42)
True
</code></pre>

<h3>REPL — удобный калькулятор</h3>

<p>Python REPL удобно использовать даже в роли обычного калькулятора, но типичный калькулятор обладает важным свойством — помнит промежуточный результат. Конечно, мы можем использовать для хранения промежуточных результатов переменную:</p>

<pre><code class="python">&gt;&gt;&gt; result = 42 * 7
&gt;&gt;&gt; result = result - 1
&gt;&gt;&gt; result = result // 2
&gt;&gt;&gt; result
146
</code></pre>

<blockquote>
<p>Обратите внимание, присваивание не приводит к выводу каких-либо значений. Тогда как любая функция возвращает что-нибудь, пусть даже и <code>None</code>, встроенные инструкции (statements) никогда не возвращают значения (и поэтому, в частности, не могут быть частью выражений).</p>
</blockquote>

<p>Использование переменных полезно, если промежуточные результаты нам понадобятся позже. Но если результат нужен только в следующем выражении, то можно использовать специальную переменную <code>_</code>, которая всегда хранит результат выполнения предыдущей команды:</p>

<pre><code class="python">&gt;&gt;&gt; 42 * 7
294
&gt;&gt;&gt; _ - 1
293
&gt;&gt;&gt; _ // 2
146
&gt;&gt;&gt; _
146
</code></pre>

<p>Вот теперь уже больше похоже на работу привычного калькулятора: промежуточные результаты и сохраняются и выводятся на экран после каждого действия!</p>

<p>Более того, переменная <code>_</code> сохраняет <em>последний успешно полученный результат</em>. Если при выполнении какой-то строчки кода произошла ошибка, то предыдущий результат не будет потерян! Также результат не теряется, если вы вводите инструкции (statements). Это удобно, к примеру, когда вы хотите сохранить текущее значение в переменную. Вот пример, который демонстрирует устойчивость к ошибкам и сохранение результата во время выполнения инструкций.</p>

<pre><code class="python">&gt;&gt;&gt; 42
42
&gt;&gt;&gt; _ // 0
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ZeroDivisionError: integer division or modulo by zero
&gt;&gt;&gt; _ // 6
7
&gt;&gt;&gt; a = _
&gt;&gt;&gt; _ + 20
27
&gt;&gt;&gt; a
7
</code></pre>

<p><strong>Важно:</strong> специальная переменная <code>_</code> доступна только в REPL, в коде программ такая переменная может быть объявлена, но работать она будет, как любая другая. Помните об этом, когда будете переносить код из REPL в модули.</p>


            </div>
  </div>
 </body>
</html>