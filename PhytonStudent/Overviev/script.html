
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width">
		<title>Phyton обзор</title>
		  <link  href="../../Design/script.css" rel="stylesheet">
		  <link  href="../../Design/toolbar.css" rel="stylesheet">
		  <script src ="../../Design/bild.js"></script>
		  </head>
     <body>
	     <script>
	 		toolbar('../../index.html','../PyMain.html');
		 </script>
			<div class="content python">
	   
<p><em>скрипт</em> (англ. <em>script</em>) — так часто называют программы на интерпретируемых
 языках, представляющие из себя простые последовательности
  команд, которые компьютеру нужно выполнить.
   Часто языки, которые максимально упрощают написание скриптов 
   и их запуск, называют "скриптовыми языками" или же "языками для написания сценариев"
    
<h3>Скрипты на Python</h3>

<p>Python отличный скриптовый язык:
<br>
 последовательность команд в простых сценариях 
 не нужно никак оформлять и запускать скрипты максимально 
 просто — мы просто пишем команды одну за другой в файл:</p>

<pre id="cmd"># file &lt;script.py&gt;
print('Hello, world!')
print('This is a python-script!')
</pre>

<p>а затем просто вызываем интерпретатор с
 полученным файлом на входе:</p>

<pre id="cmd">$ python3 script.py
Hello, world!
This is a python-script!
</pre>

<p> Написание скриптов — 
  отличная отправная точка для тех, 
  кто только начинает знакомиться с 
  программированием!</p>

<h3>Скрипты и shebang</h3>

<p>В unix-подобных операционных системах (macOS, Linux, BSD etc) 
командные оболочки умеют запускать скрипты на любых языках,
 в т.ч. и на <span>Python</span>, если эти скрипты
  сообщают оболочке, какой интерпретатор нужно вызывать 
  для выполнения сценария. Интерпретатор указывается 
  специальной строкой в самой первой строчке файла скрипта,
   которая называется <em>shebang</em>, от названий 
   первых двух символов такой строчки: 
   <br>
   <code>#</code> называется "sharp", 
   <br>а <code>!</code> - "bang!".</p>

<p>Типичный <span>shebang</span> выглядит так:</p>

<pre id="kod">#!/usr/bin/python3
</pre>

<p>где после символов <code>#!</code> идёт путь до интерпретатора. Командная оболочка при запуске скрипта, содержащего shebang, читает первую строку и пробует запустить указанный интерпретатор. Если скрипту с указанным shebang дать права на исполнение, то интерпретатор в командной строке можно будет не указывать:</p>

<pre id="cmd">$ cat script.py
<span>#!/usr/bin/python3</span>
print('Hello!')

$ chmod +x script.py

$ ./script.py
Hello!
</pre>

<p>В работе програмист может использовать разные версии <span>Python</span>,
  да и путь к интерпретатору будет отличаться от <code>/usr/bin</code>
 в виртуальных окружениях! 
 В этом случае чтобы скрипт запускался всегда с нужной версией <span>Python</span>
   нужно всего лишь не указывать путь до команды <code>python</code> напрямую,
    а использовать программу <code>env</code>.</p>

<p>Эта программа умеет находить и запускать программы с учётом 
<a href="https://ru.hexlet.io/courses/cli-basics/lessons/environment-variables/theory_unit" target="_blank">переменных окружения</a> 
и, т.к. при активации виртуального окружения модифицируется 
переменная <code>$PATH</code>, 
то <span>env</span> будет запускать именно ту версию интерпретатора, 
которая нам нужна (она просто найдётся раньше, т.к. путь до исполняемых файлов окружения добавляется в начало <code>$PATH</code>).</p>

<p>самый правильный способ указывать 
<span>shebang</span> в проектах на <span>python</span>:</p>

<pre id="cmd"><span>#!/usr/bin/env python3</span>
print('Hello!')
</pre>

<p>Путь до <code>env</code> всегда располагается именно в <code>/usr/bin/</code>
 и не встречается в нескольких версиях.
  </p>

     
        <h3>Импортирование скриптов</h3>
        
        <p>Давайте смоделируем некий исходный скрипт:</p>
        
        <pre id="cmd"># file &lt;first_script.py&gt;
        
        def greet(who):
            print('Hello, {}!'.format(who))
        
        greet('Вова')
        greet('Алла')
        </pre>
        
        <p>Далее — новый скрипт, в котором мы 
        хотим переиспользовать функцию <code>greet</code> из первого модуля
         (скрипты — тоже модули):</p>
        
        <pre id="cmd"># file &lt;second_script.py&gt;
        
        from first_script import greet
        
        greet('Витя')
        </pre>
        
        <p>Запустим первый скрипт, а затем — второй 
        (оба файла расположены в текущей директории):</p>
        
        <pre id="cmd">$ python3 first_script.py
        Hello, Вова!
        Hello, Алла!
        $ python3 second_script.py
        Hello, Вова!
        Hello, Алла!
        Hello, Витя!
        </pre>
        
        <p>Мы видим, что  при выполнении второго 
        скрипта выполнился и первый,
         хотя мы всего лишь импортировали из него одну функцию! 
    Поскольку файл первого скрипта содержит не только определения, 
    но и непосредственные действия (statements), 
    то при загрузке файла  эти действия будут выполнены. 
    
    </p>
        
        <p>Выходит, нам нужно как-то различать ситуации когда</p>
        
        <ol>
        <li>модуль выполняется как скрипт (выполняем побочные действия),</li>
        <li>модуль или его содержимое импортируются (не выполняем
        побочные действия).</li>
        </ol>
        
        <p>Для этого нам понадобится специальная переменная</p>
        
        <h3>Специальная переменная <code>__name__</code>
        </h3>
        
        <p>Машинерия импортирования при загрузке модуля в первый раз
         (первый для текущего запуска интерпретатора) добавляет в этот модуль 
         несколько переменных специального вида. 
         Этих переменных довольно много, но нам пока интересна одна — 
         переменная <code>__name__</code>.</p>
        
        <blockquote>
        <p>такие имена часто встречаются в Python-коде и как 
        правило имеют какой-то специальный смысл. 
        </p>    </blockquote>
        
        <p>Что же хранит переменная <code>__name__</code> в каждом конкретном случае? </p>
        
        <ul>
        <li>Если происходит обычный импорт, то эта переменная содержит 
        полное имя модуля (полностью квалифицированное).</li>
        <li>Если же происходит запуск в качестве скрипта, 
        то переменная получает специальное значение — строку <code>'__main__'</code>.</li>
        </ul>
        
        <p>Глядя на значение этой переменной, можем отличать 
        "запуск" от импортирования.</p>
       
        
        <p>
        перепишем наш пример<code>first_script.py</code> с применением этой переменной:</p>
        
        <pre id="cmd"># file &lt;first_script.py&gt;
        
        def greet(who):
            print('Hello, {}!'.format(who))
        
       <span> if __name__ == '__main__':</span>
            greet('Вова')
            greet('Алла')
        </pre>
        
        <h3>Функция <code>main</code>
        </h3>
<p>В теле условия <code>if __name__…</code> у нас перечислен 
набор действий, которые выполняются 
при запуске скрипта. Со временем таких действий может стать
достаточно много.   Поэтому существует соглашение: 
в теле условия <code>if __name__…</code> делают всего один
вызов функции без аргументов <code>main</code>,
 которую объявляют выше в этом же модуле
  (само условие принято располагать в самом конце модуля скрипта).</p>

<p>С учётом всех описанных рекомендаций финальная версия скрипта <code>first_script.py</code>
будет выглядеть так:</p>

<pre id="cmd"><span>#!/usr/bin/env python3</span>

def greet(who):
print('Hello, {}!'.format(who))

def main():
greet('Вова')
greet('Алла')

<span>if __name__ == '__main__':
main()</span>
</pre>

<p>Такой скрипт можно</p>

<ul>
<li>запускать непосредственно;</li>
<li>запускать из других скриптов, вызывая функцию <code>main</code>;</li>
<li>использовать как библиотеку.</li>
</ul>

<h3>Запускаемые пакеты</h3>

<p>Рассмотрим немного экзотический, но всё же встречающийся случай — запуск пакета. Могло бы показаться, что раз при загрузке пакета всегда загружается модуль <code>__init__.py</code>, то и функцию <code>main</code>, и условие нужно располагать в нём. Но авторы по ряду причин решили реализовать запуск пакетов несколько иначе: при загрузке пакета пред запуском ищется модуль <code>__main__.py</code> и выполняется, как скрипт. Здесь мы не будем углубляться в причины, побудившие авторов языка сделать именно так, и просто запомним, что исполняемые пакеты всегда содержат скрипт <code>__main__.py</code>.</p>

<p>Когда же может понадобится запуск пакета? Сходу можно представить такой пример. Пусть мы имели один небольшой скрипт. Со временем кода в нём становилось всё больше — настолько много, что этот скрипт стало совершенно невозможно поддерживать. Мы решили превратить один модуль в пакет, содержащий несколько. Но как такой пакет в дальнейшем запускать? Вот для этого мы и можем использовать модуль <code>__main__.py</code>!</p>
       

</div>
  </div>
 </body>
</html>