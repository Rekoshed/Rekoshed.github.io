
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width">
		<title>Phyton обзор</title>
		  <link  href="../../Design/script.css" rel="stylesheet">
		  <link  href="../../Design/toolbar.css" rel="stylesheet">
		  <script src ="../../Design/bild.js"></script>
		  </head>
     <body>
	     <script>
	 		toolbar('../../index.html','../PyMain.html');
		 </script>
			<div class="content">
	   
				<p>Любая программа должна быть когда-нибудь запущена, иначе зачем её вообще писать? В интерпретируемых языках от написания кода до запуска — всего один шаг. Ничего не нужно компилировать в машинный код, всю работу делает интерпретатор, которому достаточно подать на вход <em>скрипт</em> (англ. <em>script</em>) — так часто называют программы на интерпретируемых языках, представляющие из себя простые последовательности команд, которые компьютеру нужно выполнить. Часто языки, которые максимально упрощают написание скриптов (как говорят, "скриптование") и их запуск, называют "скриптовыми языками" или же "языками для написания сценариев" (слово "script" на русский переводится как "сценарий").</p>

<h3>Скрипты на Python</h3>

<p>Python отлично подходит на роль скриптового языка: последовательность команд в простых сценариях не нужно никак оформлять и запускать скрипты максимально просто — мы просто пишем команды одну за другой в файл:</p>

<pre><code class="python"># file &lt;script.py&gt;
print('Hello, world!')
print('This is a python-script!')
</code></pre>

<p>а затем просто вызываем интерпретатор с полученным файлом на входе:</p>

<pre><code class="sh">$ python3 script.py
Hello, world!
This is a python-script!
</code></pre>

<p>Эта простота использования вместе с большим количеством полезных модулей и функций, входящих в поставку Python, делают последний хорошим инструментом для автоматизации различных задач, которые не хочется выполнять вручную при работе на компьютере. К тому же написание скриптов — отличная отправная точка для тех, кто только начинает знакомиться с программированием!</p>

<h3>Скрипты и shebang</h3>

<p>В unix-подобных операционных системах (macOS, Linux, BSD etc) командные оболочки умеют запускать скрипты на любых языках, в т.ч. и на Python, если эти скрипты сообщают оболочке, какой интерпретатор нужно вызывать для выполнения сценария. Интерпретатор указывается специальной строкой в самой первой строчке файла скрипта, которая называется <em>shebang</em>, от названий первых двух символов такой строчки: <code>#</code> называется "sharp", а <code>!</code> - "bang!".</p>

<p>Типичный shebang выглядит так:</p>

<pre><code class="python">#!/usr/bin/python3
</code></pre>

<p>где после символов <code>#!</code> идёт путь до интерпретатора. Командная оболочка при запуске скрипта, содержащего shebang, читает первую строку и пробует запустить указанный интерпретатор. Если скрипту с указанным shebang дать права на исполнение, то интерпретатор в командной строке можно будет не указывать:</p>

<pre><code class="sh">$ cat script.py
#!/usr/bin/python3
print('Hello!')

$ chmod +x script.py

$ ./script.py
Hello!
</code></pre>

<h3>Shebang и разные версии Python</h3>

<p>shebang — штука довольно простая, когда интерпретатор в системе ровно один. Но мы с вами знаем, что версий Python в системе может быть установлено несколько. Более того, в виртуальном окружении — а в работе вы практически всегда будете их использовать — путь к интерпретатору будет отличаться от <code>/usr/bin</code> и будет разным в разных окружениях! Как же сделать так, чтобы скрипт запускался всегда с нужной версией Python? Есть способ добиться такой универсальности: нужно всего лишь не указывать путь до команды <code>python</code> напрямую, а использовать программу <code>env</code>.</p>

<p>Эта программа умеет находить и запускать программы с учётом <a href="https://ru.hexlet.io/courses/cli-basics/lessons/environment-variables/theory_unit" target="_blank">переменных окружения</a> и, т.к. при активации виртуального окружения модифицируется переменная <code>$PATH</code>, то env будет запускать именно ту версию интерпретатора, которая нам нужна (она просто найдётся раньше, т.к. путь до исполняемых файлов окружения добавляется в начало <code>$PATH</code>).</p>

<p>Итак, представляем правильный способ указывать shebang в проектах на python! Встречайте:</p>

<pre><code class="python">#!/usr/bin/env python3
print('Hello!')
</code></pre>

<p>Путь до <code>env</code> указан конкретный потому, что эта программа практически всегда располагается именно там и не встречается в нескольких версиях :) А запомнить это правило написания shebang очень легко — "вызываем python3 с учётом окружения" ("env", это сокращение от "environment"/"окружение").</p>

<body>
        <p>Как писать скрипты, мы уже узнали. Теперь представим, что у нас есть файл с кодом, который мы запускаем как скрипт. Файл разрастается, в нём появляются функции и прочие определения. В какой-то момент мы понимаем, что хотим переиспользовать, скажем, функцию из этого модуля в другом модуле. Значит, нужно импортировать!</p>
        
        <h3>Импортирование скриптов</h3>
        
        <p>Давайте же смоделируем описанную выше ситуацию. Так будет выглядеть исходный скрипт:</p>
        
        <pre><code class="python"># file &lt;first_script.py&gt;
        
        def greet(who):
            print('Hello, {}!'.format(who))
        
        greet('Bob')
        greet('Ann')
        </code></pre>
        
        <p>А так — новый скрипт, в котором мы хотим переиспользовать функцию <code>greet</code> из первого модуля (скрипты — тоже модули):</p>
        
        <pre><code class="python"># file &lt;second_script.py&gt;
        
        from first_script import greet
        
        greet('Thomas')
        </code></pre>
        
        <p>Запустим первый скрипт, а затем — второй (оба файла расположены в текущей директории):</p>
        
        <pre><code class="sh">$ python3 first_script.py
        Hello, Bob!
        Hello, Ann!
        $ python3 second_script.py
        Hello, Bob!
        Hello, Ann!
        Hello, Thomas!
        </code></pre>
        
        <p>Что мы видим — при выполнении второго скрипта выполнился и первый, хотя мы всего лишь импортировали из него одну функцию! Такова цена за простоту написания скриптов! Поскольку файл первого скрипта содержит не только определения, но и непосредственные действия (statements), то при загрузке файла (которая происходит при импорте модуля) эти действия будут выполнены. Теперь представьте, что мы бы импортировали скрипт, в котором не просто что-то печатается на экран, а удаляются какие-то файлы или того хуже — запускаются межконтинентальные ракеты!</p>
        
        <p>Выходит, нам нужно как-то различать ситуации когда</p>
        
        <ol>
        <li>модуль выполняется как скрипт (выполняем побочные действия),</li>
        <li>модуль или его содержимое импортируются (не выполняем
        побочные действия).</li>
        </ol>
        
        <p>Для этого нам понадобится немного магии!</p>
        
        <h3>Специальная переменная <code>__name__</code>
        </h3>
        
        <p>Машинерия импортирования при загрузке модуля в первый раз (первый для текущего запуска интерпретатора) добавляет в этот модуль несколько переменных специального вида. Этих переменных довольно много, но нам пока интересна одна — переменная <code>__name__</code>.</p>
        
        <blockquote>
        <p>Не стоит пугаться такого странного имени аж с четыремя символами подчёркивания: такие имена часто встречаются в Python-коде и как правило имеют какой-то специальный смысл. Опытный питонист помнит наизусть пару десятков таких переменных, а ещё про эти переменные любят спрашивать на собеседованиях.</p>
        </blockquote>
        
        <p>Что же хранит переменная <code>__name__</code> в каждом конкретном случае? В этом и весь секрет!</p>
        
        <ul>
        <li>Если происходит обычный импорт, то эта переменная содержит полное имя модуля (полностью квалифицированное).</li>
        <li>Если же происходит запуск в качестве скрипта, то переменная получает специальное значение — строку <code>'__main__'</code>.</li>
        </ul>
        
        <p>Глядя на значение этой переменной, можем отличать "запуск" от импортирования.</p>
        
        <blockquote>
        <p>Слово "main" используется во многих языках для именования функции, которая вызывается автоматически при старте программы, потому и в Python это слово используется в похожем смысле</p>
        </blockquote>
        
        <p>Давайте вернёмся к нашему примеру и перепишем <code>first_script.py</code> с применением этого нового знания:</p>
        
        <pre><code class="python"># file &lt;first_script.py&gt;
        
        def greet(who):
            print('Hello, {}!'.format(who))
        
        if __name__ == '__main__':
            greet('Bob')
            greet('Ann')
        </code></pre>
        
        <p>Теперь наш скрипт не будет приветствовать Боба и Энн, если мы будем импортировать модуль. Это победа!</p>
        
        <h3>Функция <code>main</code>
        </h3>
        
        <p>Наш <code>first_script.py</code> уже достаточно хорош. Но мы можем его ещё чуть-чуть улучшить.</p>
        
        <p>В теле условия <code>if __name__…</code> у нас перечислен набор действий, которые выполняются при запуске скрипта. Со временем таких действий может стать достаточно много. И, как вы бы догадались, может статься, что мы захотим переиспользовать и этот кусок кода! Скажу даже больше, такое происходит нередко. Поэтому существует соглашение: в теле условия <code>if __name__…</code> делают всего один вызов функции без аргументов <code>main</code>, которую объявляют выше в этом же модуле (само условие принято располагать в самом конце модуля скрипта).</p>
        
        <p>С учётом всех описанных рекомендаций финальная версия скрипта <code>first_script.py</code> будет выглядеть так:</p>
        
        <pre><code class="python">#!/usr/bin/env python3
        
        def greet(who):
            print('Hello, {}!'.format(who))
        
        def main():
            greet('Bob')
            greet('Ann')
        
        if __name__ == '__main__':
            main()
        </code></pre>
        
        <p>Такой скрипт можно</p>
        
        <ul>
        <li>запускать непосредственно;</li>
        <li>запускать из других скриптов, вызывая функцию <code>main</code>;</li>
        <li>использовать как библиотеку.</li>
        </ul>
        
        <h3>Запускаемые пакеты</h3>
        
        <p>Рассмотрим немного экзотический, но всё же встречающийся случай — запуск пакета. Могло бы показаться, что раз при загрузке пакета всегда загружается модуль <code>__init__.py</code>, то и функцию <code>main</code>, и условие нужно располагать в нём. Но авторы по ряду причин решили реализовать запуск пакетов несколько иначе: при загрузке пакета пред запуском ищется модуль <code>__main__.py</code> и выполняется, как скрипт. Здесь мы не будем углубляться в причины, побудившие авторов языка сделать именно так, и просто запомним, что исполняемые пакеты всегда содержат скрипт <code>__main__.py</code>.</p>
        
        <p>Когда же может понадобится запуск пакета? Сходу можно представить такой пример. Пусть мы имели один небольшой скрипт. Со временем кода в нём становилось всё больше — настолько много, что этот скрипт стало совершенно невозможно поддерживать. Мы решили превратить один модуль в пакет, содержащий несколько. Но как такой пакет в дальнейшем запускать? Вот для этого мы и можем использовать модуль <code>__main__.py</code>!</p>
                   

</div>
  </div>
 </body>
</html>