
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width">
		<title>PHP оснрвные конструкции</title>
		  <link  href="../../Design/script.css" rel="stylesheet">
		  <link  href="../../Design/toolbar.css" rel="stylesheet">
		  <script src ="../../Design/bild.js"></script>
		  </head>
     <body>
	     <script>
	 		toolbar('../../index.html','../PHP_main.html');
		 </script>
		 <style type="text/css">
		 
		 </style>
			<div class="content">
		
<h1>Основные конструкции языка PHP.</h1>
<h2>Типы данных и переменные</h2>
<pre class="php">
&lt;?php

<span id="br"># Числа</span>

$one = 1;
$number = -100;

<span id="br"># Строки</span>

$str1 = 'i am a string';
$str2 = "i am a string too";

<span id="br"># Логические значения</span>

$yes = true;
$no = false;
</pre>
<h2>Преобразование типов</h2>
<pre class="php">
&lt;?php

<span id="br"># Числа</span>

$one = (int) '234';
$two = (string) 34;
</pre>

<h2>Операции</h2>

<pre class="php">
&lt;?php

<span id="br">// Арифметические операции</span>

1 + 5 - 8 * 6 / 2 ** 3 % 4;

<span id="br">// Логические операции</span>

true || false && !true

<span id="br">// Создание переменных</span>

$str = 'i am a string';

<span id="br">// Обращение к символам строки</span>

$str[0]; // i
print_r("{$str}"); // => i am a string
print_r($str); // => i am a string
</pre>

<h2>Условные операторы:</h2>
 
 <ol>
   <li> <h3><span id="br">if</span></h3> </li>
<pre class="php">
&lt;?php
if (логическое выражение)
оператор;
?>
</pre>
<p> Если <code>логическое выражение</code>  истинно (true), то <code>оператор</code> будет исполнен</p>
 <p>Соответственно, если <code> логическое выражение</code> ложно (false), то  <code>оператор</code> не исполняется. :</p>
</p>
<pre id="kod">
&lt;?php
if ($a > $b) echo "значение a больше, чем b";
?>
</pre>
<li><h3><span id="br">else</span></h3></li>
<pre class="php">
&lt;?php
if (логическое выражение)
инструкция_1;
else
инструкция_2;
?>
</pre>
<p>Если логическое выражение истинно, то выполняется <code>инструкция_1</code></p>
<p>Иначе — выпооняется <code>инструкция_2</code>.</p>
<pre id="kod">
&lt;?php
if ($a > $b) {
echo "a больше, чем b";
} else {
echo "a НЕ больше, чем b";
}
?>
</pre>
<li><h3><span id="br"> if-else.</span></h3></li>
<pre class="php">
&lt;?php
if (логическое_выражение):
команды;
elseif(другое_логическое_выражение):
другие_команды;
else:
иначе_команды;
endif
?>
</pre>
<li> <h3><span id="br">elseif</span></h3></li>

elseif – это комбинация конструкций if и else. Эта конструкция расширяет условную конструкцию if-else.
<pre class="php">
&lt;?php
if (логическое_выражение_1)
оператор_1;
elseif (логическое_выражение_2)
оператор_2;
else
оператор_3;
?>
</pre>

<p>Пример:</p>
<pre id="kod">
&lt;?php
if ($a > $b) {
echo "a больше, чем b";
} elseif ($a == $b) {
echo "a равен b";
} else {
echo "a меньше, чем b";
}
?>
</pre>
</ol>

<h2> Циклы:</h2>
 <ol>
   <li><h3><span id="br"> while</span></h3></li>

<pre class="php">
&lt;?php
while (логическое выражение)
тело цикла;
?>
</pre>

<p>Если  <code> логическое выражение</code>истинно, выполняется тело цикла, в противном случае – переходим на следующий за циклом оператор.</p>
<p>Пример:</p>
<pre id="kod">
&lt;?php
$x=0;
while ($x++&lt;10) echo $x;
// Выводит 12345678910
?>
</pre>
   <li><h3><span>do while</span></h3></li>
<p>
В отличие от цикла while, этот цикл проверяет значение выражения не до, а после каждого прохода. Таким образом, тело цикла выполняется хотя бы один раз.
</p>
<pre id="kod">
&lt;?php
do
{
тело_цикла;
}
while (логическое_выражение);
?>
</pre>
<p>
После очередной итерации проверяется, истинно ли логическое_выражение, и, если это так, управление передается вновь на начало цикла, в противном случае цикл обрывается. Пример скрипта:
</p>
<pre id="kod">
&lt;?php
$x = 1;
do {
echo $x;
} while ($x++&lt;10);
?>
</pre>
<li><h3><span> for</span></h3></li>
<pre class="php">
&lt;?php
for (инициализирующие_команды; условие_цикла; команды_после_итерации) { тело_цикла; }
?>
</pre>
<p>
Цикл <span>for</span> начинает свою работу с выполнения <code>инициализирующих_команд</code>.
<br>Данные команды выполняются только один раз.</p>
<p>
После этого проверяется <code>условие_цикла</code>,
 если оно истинно (true), то выполняется <code>тело_цикла</code>. 
 После того, как будет выполнен последний оператор тела, выполняются <code>команды_после_итерации</code>.
  Затем снова проверяется <code>условие_цикла</code>. Если оно истинно (true), выполняется <code>тело_цикла</code> и <code>команды_после_итерации.</code>
</p>
<pre id="kod">
&lt;?php
for ($x=0; $x&lt;10; $x++) echo $x;
//Выведит 0123456789
?>
</pre>
<p>
Для цикла <span id="br">for</span> имеется и альтернативный синтаксис:
</p>
<pre class="php">
&lt;?php
for(инициализирующие_команды; условие_цикла; команды_после_итерации):
операторы;
endfor;
?>
</pre>
<li><h3><span id="br">foreach</span></h3></li>
<pre class="pho">
&lt;?php
foreach (массив as $ключ=>$значение)
команды;
?>
</pre>
<p>
Команды циклически выполняются для каждого элемента массива,
 при этом очередная пара <code>ключ=>значение</code> оказывается в переменных <code>$ключ</code> и <code>$значение</code>. 
</p>
 <p>Пример:</p>
<pre id="kod">
&lt;?php
$names["Иванов"] = "Андрей";
$names["Петров"] = "Борис";
$names["Волков"] = "Сергей";
$names["Макаров"] = "Федор";
foreach ($names as $key => $value) {
echo "&lt;b>$value $key&lt;/b>&lt;br>";
}
?>
</pre>
<p>Рассмотренный сценарий выводит:</p>
<pre>
Андрей Иванов
Борис Петров
Сергей Волков
Федор Макаров
</pre>
<p>
У цикла <span>foreach</span> имеется и другая форма записи,
которую следует применять, когда нас не интересует значение ключа очередного элемента.
</p>
<pre class="php">
&lt;?php
foreach (массив as $значение)
команды;
?>
</pre>
<p>
Цикл <span>foreach</span> оперирует не исходным массивом, а его копией.
 Это означает, что любые изменения, которые вносятся в массив,
  не могут быть “видны” из тела цикла. 
  Что позволяет в качестве массива использовать не только переменную,
   но и результат работы какой-нибудь функции, возвращающей массив (в этом случае функция будет вызвана всего один раз – до начала цикла, а затем работа будет производиться с копией возвращенного значения).
</p>
<li><h3><span id="br">break</span></h3></li>
 <p>конструкция <span>break</span>, которая осуществляет немедленный выход из цикла.</p>
<pre class="php">
&lt;?php
break; // По умолчанию
break(номер_цикла); // Для вложенных циклов (указывается номер прерываемого цикла)
?>
</pre>
<p>Пример:</p>
<pre id="kod">
&lt;?php
$x=0;
while ($x++&lt;10) {
if ($x==3) break;
echo "&lt;b>Итерация $x&lt;/b>&lt;br>";
}
// Когда $x равен 3, цикл прерывается
?>
</pre>

<p>
Если нам нужно прервать работу определенного (вложенного) цикла, 
то нужно передать конструкции break параметр –
 номер_цикла, например, break(1). </p>
 <p>Нумерация циклов выглядит так:</p>
<pre class="php">
for (...) // Третий цикл
{
for (...) // Второй цикл
{
for (...) // Первый цикл
{
}
}
}
</pre>
 <li><h3><span id="br">continue</span></h3></li>
<p>
Конструкция <span>continue</span> завершает текущую итерацию цикла и переходит к новой.
</p>
<pre id="kod">
&lt;?php
$x=0;
while ($x++&lt;5) {
if ($x==3) continue;
echo "&lt;b>Итерация $x&lt;/b>&lt;br>";
}
// Цикл прервется только на третьей итерации
?>
</pre>
<p>
Cкрипт выведет:
</p>
<pre>
Итерация 1
Итерация 2
Итерация 4
Итерация 5
</pre>
</ol>
<h3>Конструкция выбора <span id="br">switch-case</span></h3>
<pre class="php">
&lt;?php
switch(выражение) {
case значение1: команды1; [break;]
case значение2: команды2; [break;]
. . .
case значениеN: командыN; [break;]
[default: команды_по_умолчанию; [break]]
}
?>
</pre>
<p>
Вычисляется <code> выражение</code>;
<br>
<code>команда N</code> выполняется если <code>значение N</code> равно выражению.</p>
<p>Пример в сравнении с <span>if-else</span>:</p>
<pre id="kod">
&lt;?php
$x=1;
// Используем if-else
if ($x == 0) {
echo "x=0&lt;br>";
} elseif ($x == 1) {
echo "x=1&lt;br>";
} elseif ($x == 2) {
echo "x=2&lt;br>";
}
<span id="bs">// Используем switch-case</span>
switch ($x) {
case 0:
echo "x=0&lt;br>";
break;
case 1:
echo "x=1&lt;br>";
break;
case 2:
echo "x=2&lt;br>";
break;
}
?>
</pre>

<h2>Функции</h2>
<pre class="php">
&lt;?php

<span id="br">// Определение</span>
function sum(a,b)
{
    $c = a + b;
    echo $c;
}

<span id="br">// Вызов</span>
sum(3,5); // выводит 8

</pre>
<p>Пример выше не является чистой функцией</p>

<h3>Конструкция возврата значений <span id="br">return</span></h3>
<pre class="php">
&lt;?php
function retfunct()
{
return 7;
}
echo retfunct();   // выводит '7'.
?>
</pre>
<p>Пример возврата конструкцией <b>return</b> массивов:</p>
<pre id="kod">
&lt;?php
function numbers()
{
return array (0, 1, 2);
}
list ($zero, $one, $two) = numbers();
echo $zero;
echo $one;
echo $two;
// Выводит '012'
?>
</pre>
<h2>Конструкции включений:</h2>

<p>Конструкции включений позволяют собирать PHP программу (скрипт) из нескольких отдельных файлов.</p>
<ol>
 <li><span id="br"><h3>require()</h3></span></li>
<p>
Конструкция <b>require</b> позволяет включать код до выполнения сценария.
</p>
<pre class="php">
require имя_файла;
</pre>
<p>
При запуске программы интерпретатор заменит инструкцию на содержимое файла имя_файла (этот файл может также содержать сценарий на PHP).
</p>
<li><h3><span id="br">include</span></h3></li>
<p>
Конструкция <b>include</b> также предназначена для включения файлов в код сценария PHP.
 В отличие от конструкции require конструкция include позволяет включать файлы в код PHP скрипта во время выполнения сценария.
</p>
<pre class="php">
include имя_файла;
</pre>

<li><span><h3> require_once и include_once</h3></span></li>
<p>
Используя конструкции однократного включения <b>require_once и include_once</b>,
 можно быть уверенным, что один файл не будет включен дважды. 
 Работают конструкции <b>require_once и include_once</b> так же, как и 
 <b>requre и include</b>. 
 Разница в их работе лишь в том, что перед включением файла интерпрететор проверяет,
  включен ли указанный файл ранее или нет. Если да, то файл не будет включен вновь.

</p>
</ol>
<pre class="php"> 
&lt;?php

<span id="b">// file: print.php</span>

function sayHi()
{
    print_r('Hi!');
}

<span id="b">// file: index.php</span>

require_once 'print.php';

sayHi(); // => Hi!

</pre>
<p>Рассмотрим следующий пример</p>
<pre class="php">
&lt;?php

<span id="b">// file: print.php</span>

print_r("Hi from print.php!\n");


<span id="b">// file: index.php</span>

require_once 'print.php';

print_r("Hi from index.php!\n");
</pre>
<p>Попробуем запустить:</p>
<pre class="cmd">
$ php index.php
Hi from print.php!
Hi from index.php!
</pre>
<p>
Видно, что сначала выполнился код, находящийся во включаемом файле, и только потом код в файле index.php.
 
Этот механизм рекурсивен по своей природе: если во включаемом файле есть другой включаемый файл, то сначала исполнится он. Такое поведение чем-то похоже на матрешку.
 Можно сказать, что весь код всех файлов проекта находится в одном пространстве и доступен для использования напрямую.
</p>
<p>
Из всех четырех конструкций для включения файлов пользоваться имеет смысл только одной
 —<b> require_once</b>. Она обладает двумя важными свойствами:
</p>
<ul>
<li>Если файл отсутствует, то эта конструкция приведет к ошибке,
 и программа остановит свое выполнение;</li>
<li>Если в <b>require_once</b> передается файл, который уже был 
где-то загружен ранее, то она не будет выполнять этот файл повторно,
 но код этого файла все равно станет доступным.</li>
</ul>
<p>
Эти два условия важны, так как код, опирающийся на них, получается более качественным и простым.
 В отличие от <b>require_once</b>, остальные конструкции не отвечают
  этим требованиям: <b>require</b> исполняет включаемый файл каждый раз, а include и include_once не приводят к ошибке в ситуации,
   когда файла не существует.</p>


	     </div>
  </div>
 </body>
</html>