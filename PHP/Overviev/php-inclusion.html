
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width">
		<title>PHP оснрвные конструкции</title>
		  <link  href="../../Design/script.css" rel="stylesheet">
		  <link  href="../../Design/toolbar.css" rel="stylesheet">
		  <script src ="../../Design/bild.js"></script>
		  </head>
     <body>
	     <script>
	 		toolbar('../../index.html','../PyMain.html');
		 </script>
		 <style type="text/css">
		 .php
		  {
		  color:#225;
		  font-weight:800;
		  }
		  
		  code
		  {
		  color:#225;
		  font-size:1.2em;
		  }
		  
		  .cmd {/*стилизуем команды терминала*/
		  color:purple;
		  font-weight:800;
		  background-color:khaki;
		  }
		  
		 </style>
			<div class="content">
		<h1>Включения и пространство имён</h1>
<h2>Конструкции включений:</h2>

<p>Конструкции включений позволяют собирать PHP программу (скрипт) из нескольких отдельных файлов.</p>
<ol>
 <li><span id="br"><h3>require()</h3></span></li>
<p>
Конструкция <b>require</b> позволяет включать код до выполнения сценария.
</p>
<pre class="php">
require имя_файла;
</pre>
<p>
При запуске программы интерпретатор заменит инструкцию на содержимое файла имя_файла (этот файл может также содержать сценарий на PHP).
</p>
<li><h3><span id="br">include</span></h3></li>
<p>
Конструкция <b>include</b> также предназначена для включения файлов в код сценария PHP.
 В отличие от конструкции require конструкция include позволяет включать файлы в код PHP скрипта во время выполнения сценария.
</p>
<pre class="php">
include имя_файла;
</pre>

<li><span><h3> require_once и include_once</h3></span></li>
<p>
Используя конструкции однократного включения <b>require_once и include_once</b>,
 можно быть уверенным, что один файл не будет включен дважды. 
 Работают конструкции <b>require_once и include_once</b> так же, как и 
 <b>requre и include</b>. 
 Разница в их работе лишь в том, что перед включением файла интерпрететор проверяет,
  включен ли указанный файл ранее или нет. Если да, то файл не будет включен вновь.

</p>
</ol>
<pre class="php"> 
&lt;?php

<span id="b">// file: print.php</span>

function sayHi()
{
    print_r('Hi!');
}

<span id="b">// file: index.php</span>

require_once 'print.php';

sayHi(); // => Hi!

</pre>
<p>Рассмотрим следующий пример</p>
<pre class="php">
&lt;?php

<span id="b">// file: print.php</span>

print_r("Hi from print.php!\n");


<span id="b">// file: index.php</span>

require_once 'print.php';

print_r("Hi from index.php!\n");
</pre>
<p>Попробуем запустить:</p>
<pre class="cmd">
$ php index.php
Hi from print.php!
Hi from index.php!
</pre>
<p>
Видно, что сначала выполнился код, находящийся во включаемом файле, и только потом код в файле index.php.
 
Этот механизм рекурсивен по своей природе: если во включаемом файле есть другой включаемый файл, то сначала исполнится он. Такое поведение чем-то похоже на матрешку.
 Можно сказать, что весь код всех файлов проекта находится в одном пространстве и доступен для использования напрямую.
</p>
<p>
Из всех четырех конструкций для включения файлов пользоваться имеет смысл только одной
 —<b> require_once</b>. Она обладает двумя важными свойствами:
</p>
<ul>
<li>Если файл отсутствует, то эта конструкция приведет к ошибке,
 и программа остановит свое выполнение;</li>
<li>Если в <b>require_once</b> передается файл, который уже был 
где-то загружен ранее, то она не будет выполнять этот файл повторно,
 но код этого файла все равно станет доступным.</li>
</ul>
<p>
Эти два условия важны, так как код, опирающийся на них, получается более качественным и простым.
 В отличие от <b>require_once</b>, остальные конструкции не отвечают
  этим требованиям: <b>require</b> исполняет включаемый файл каждый раз, а include и include_once не приводят к ошибке в ситуации,
   когда файла не существует.</p>

<p>Сейчас пррграммисты называют такое поведение языка абсолютным злом.
Т.к когда создавался PHP болших библиотек ещё не существовало, и такого механизма включения
чтобы разбить сложный код на части вполне было достаточно.</p>
<p>Cовременный стандарт разработки на языке PHP полагается на механизм автозагрузки и запрещает использование явного включения файлов.
 И в реальном коде за включение файлов отвечает <strong>Composer</strong> — менеджер управления зависимостями, его мы рассмотрим позже.</p>
 
 <h2>Пространства имён.</h2>
 <p> Но всё же механизм включения в PHP существует.
 И мы его рассмртрим что бы понять как он работает впринципе.</p>
 
 <p>Приложения на PHP состоят из многих тысяч строк кода. 
 Значительная часть этого кода приходит из библиотек, написанных другими людьми,
  и почти наверняка мы не знаем, как они там внутри устроены.
   Чем больше библиотек вы используете, чем больше разработчиков в проекте и,
    собственно, кода проекта, тем выше вероятность того, что вы начнете натыкаться на  ошибку <code>Cannot redeclare</code>.
     
    Это прризойдёт когда мы попытатемся определить в коде две разные функции,
     но с одинаковыми именами:</p>
   <pre class="php">  
 &lt;?php
 
 // file: index.php
 
 function foo()
 {
 print_r('one');
 }
 
 function foo()
 {
 print_r('two');
 }
 $ php index.php
<span id="br"> PHP Fatal error:  Cannot redeclare foo() (previously declared in /private/var/tmp/index.php:3)</span>
</pre> 
     
     <p>
     Более того, может оказаться так, что две разные библиотеки, которые вам так нужны в проекте,
      имеют одинаковые имена функций, а, следовательно, вы физически не сможете их использовать вместе.
       А включение каждой новой библиотеки в код проекта почти наверняка заставит переименовывать функции самого проекта.
     </p>
 <p>
 Начиная с PHP версии 5.3 в языке появился механизм пространств имен, в задачу которого входит изоляция кода разных файлов друг от друга. 
 Концепция такого механизма встречается в нашей жизни повсеместно.
  В файловой системе роль пространств имён выполняют директории, в телефонах - код страны, в адресах - страны, города и улицы. 
  </p>
  <p>В силу исторических причин, пространства имён появились позже включений.
  По этому в языке PHP появились
    по сути, два независимых механизма, 
    один - включение файлов как таковых, 
    другой - пространства имён.
  </p>
  
  <p>Перейдём к примеру:</p>
 <pre class="php"> 
  &lt;?php
  
  // math.php
  
  namespace math;
  
  function sum($a, $b)
  {
  return $a + $b;
  }
  </pre>
 <p> Пространство имён задается с помощью ключевого слова <span>namespace</span>, 
 за которым следует имя пространства имён. 
 По стандарту, один файл должен соответствовать одному пространству имён, 
 как в примере выше. В случае, когда внутри пространства имён 
 определяются только функции (а не классы, с которыми мы познакомимся позже), 
 имя пространства имён должно соответствовать имени файла с учетом регистра,
  то есть, для нашего примера имя файла -<code> math.php</code>, следовательно, 
  имя пространства имён - <code>math</code>. 
  Теперь посмотрим на то, как использовать функции, определенные в пространстве имён:
  </p>
  
  <pre class="php">
  &lt;?php
  
  // index.php
  
  require_once 'math.php';
  
  // Обратиться напрямую к функции sum не получится:
  // PHP Fatal error:  Uncaught Error: Call to undefined function sum()
  sum(3, 2);
  
  // А если указать пространство имён, то все работает:
  \math\sum(5, 8); // 13
  </pre>
  <p>
  Попытка обратиться к функции по имени приведет к ошибке, 
  так как она скрыта за пространством имён. 
  Правильный вызов выглядит так:<span> \&lt;имя пространства имён>\&lt;имя функции></span>.</p>
  <p>
   Рассмотрим еще один пример, когда функция с одним и тем же именем определена в разных пространствах имён:
 </p>
 <pre class="php"> 
  &lt;?php
  
  // index.php
  
  require_once 'text.php';
  require_once 'number.php';
  
  // Эта функция повторяет строчку, переданную первым параметром столько раз, сколько указано во втором параметре:
  \text\multi('hi', 3); // hihihi
  \number\multi(3, 2); // 6
  </pre>
  <p>
  Два пространства имён имеют одинаковые функции, но, как видно из кода, это не создает неудобств.
   Каждая функция вызывается с указанием собственного пространства имен. 
   Более того, мы можем определить функцию <code>multi</code> прямо в том месте,
    куда производится включение других пространств имён:
  </p>
  <pre class="php">
  &lt;?php
  
  // index.php
  
  require_once 'text.php';
  require_once 'number.php';
  
  function multi($a, $b)
  {
  print_r('it works!');
  }
  
  // Эта функция повторяет строчку, переданную первым параметром столько раз, сколько указано во втором параметре:
  \text\multi('hi', 3); // hihihi
  \text\multi('ho', 2); // hoho
  \number\multi(3, 2); // 6
  
  multi(2, 3); // it works!
  </pre>
  
  <h2>Вложенные пространства имён</h2>
  <p>
  Файловая структура практически любого проекта на PHP выглядит так:</p>
  <pre class="php">
  src/
  tests/
  composer.json
  composer.lock
  .git
  README.md
  </pre>
  <p>
  Директория <span>src</span> предназначена для хранения исходного кода программы (сайта).
  Внутри <span>src</span> могут находиться другие директории с PHP файлами внутри них:
  </p>
  <pre class="php">
  my-site/
  src/
  Formatters/
  Pretty.php
  Generator.php
  </pre>
  <p>Как же отразить файловую структуру на пространство имён?</p>
    <p>Если посмотреть на другие языки, например, python или java, то там структура пакетов "намертво" 
  связана с файловой структурой. 
   В PHP это правило задано на уровне соглашений. 
   По стандарту структура пространств имён должна один в один
    соответствовать файловой структуре.</p>
  <p>
  Если взять файл <code>Pretty.php</code>, то его пространство имён следовало бы назвать 
  <span>FormattersPretty</span>, что отражает вложенность <span>Formatters/Pretty</span>. 
  Но можно сделать еще лучше — использовать вложенные пространства имён:</p>
  <pre class="php">
  &lt;?php
  
  namespace Formatters\Pretty;
  
  function render($data)
  {
  // some code
  }
  </pre>
  <p>
  Возможность вкладывать пространства имён друг в друга позволяет думать о пространствах 
  имен как о файловой структуре, где пространства имён
   — это директории, а функции — это файлы. 
   Кроме вложенности, такие пространства имён ничем не отличаются от 
   обычных пространств имён:</p>
  
  <pre class="php">
  &lt;?php
  
  namespace Generator;
  
  function generate($data)
  {
  return \Formatters\Pretty\render($data);
  }
  </pre>
  <p>
  Описанная выше схема именования пространств помогает избавиться 
  от большого числа проблем, связанных с коллизиями.
   Но все же этого недостаточно. 
   Дело в том, что теперь сами пространства становятся уникальными и не должны 
   пересекаться. А пространство с именем <span>Generator</span>, 
   скорее всего, будет периодически встречаться в разных библиотеках 
   (так как это слишком общее слово). Поэтому каждый проект или пакет принято помещать в одно 
   общее пространство и не загрязнять глобальное пространство множеством пространств имён.
    Это название выбирается на основе названия самого проекта — 
    той директории, внутри которой лежит <code>src</code>. 
    В нашей структуре директорий это <code>my-site.</code> Это значит, 
    что общим пространством для всех файлов внутри <code>src</code> будет <code>MySite</code>:</p>
  
  <pre class="php">
  &lt;?php
  // src/Formatters/Pretty.php
  namespace MySite\Formatters\Pretty;
  
  // some code
 
  
  &lt;?php
  
  // src/Generator.php
  namespace MySite\Generator;
  
  // some code
  </pre>
  
  
  <h2>Импорт функций</h2>
  <p>Теперь снова вернёмся к предыдущему примеру:</p>
  
  <pre class="php">
  &lt;?php
  
  namespace Generator;
  
  function generate($data)
  {
  return \Formatters\Pretty\render($data);
  }
  </pre>
  <p>
  А если понадобится вызвать эту функцию много раз?
   В глазах быстро начнёт рябить от обратных слешей. 
   Для решения этой задачи придумали механизм импорта. 
   С его помощью можно "импортировать" функцию в текущее пространство имён так,
    как будто она определена прямо здесь:</p>
  
  <pre class="php">
  &lt;?php
  
  namespace Generator;
  
  use function Formatters\Pretty\render;
  
  function generate($data)
  {
  return render($data);
  }
  </pre>
  
  <p>
  Импорт функции, выполняется оператором <span id="br">use</span>, 
  за которым идёт ключевое слово <span>function</span> и затем полный путь до функции 
  с указанием всех его пространств имён без ведущего обратно слеша.
   Количество импортов ничем не ограничено. 
   Их используют и добавляют исключительно по соображениям удобства:</p>
  <pre class="php">
  &lt;?php
  
  namespace PhpPairs\Lists;
  
  use function PhpPairs\Pairs\cons;
  use function PhpPairs\Pairs\car;
  use function PhpPairs\Pairs\cdr;
  use function PhpPairs\Pairs\toString;
  </pre>
  <p> Если в текущем пространстве определена функция с
   таким именем, либо функция с таким именем была импортирована ранее из другого 
   пространства имён. Сделать это можно через алиасы (псевдонимы) —
    механизм, позволяющий переименовывать импортируемые функции.</p>
  
  <pre class="php">
  &lt;?php
  
  namespace Generator;
  
  use function Formatters\Pretty\render;
  use function Formatters\Simple\render as simpleRender;
  
  function generate($data)
  {
  return simpleRender($data);
  }
  </pre>
  <p>
  Для переименования достаточно в конце импорта добавить ключевое слово <span id="br">as</span>, 
  а затем имя, под которым функция должна стать доступна.</p>
	     </div>
  </div>
 </body>
</html>