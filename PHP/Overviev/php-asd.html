
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width">
		<title>PhP обзор</title>
		  <link  href="../../Design/script.css" rel="stylesheet">
		  <link  href="../../Design/toolbar.css" rel="stylesheet">
		  <script src ="../../Design/bild.js"></script>
		  </head>
     <body>
	     <script>
	 		toolbar('../../index.html','../PHP_main.html');
		 </script>
		 
		 <style type="text/css">
		 
		 </style>
			<div class="content php-content">
	  
                    Структуры данных или Абстрактный Тип Данных (<abbr title="abstract data type">ADT</abbr>) — это модель, определенная как некий набор операций, которые могут быть применены к самой себе и ограничена тем, какой результат дают эти операции.<br/>
                    Большинство из нас сталкиваются со стеком и очередью в повседневной жизни, но что общего между очередью в супермакете и структурой данных? В этом мы и попробуем разобраться в данной статье, где также будут описаны деревья.<br/>
                    <br/>
                    <nobr><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ac/224/f8c/7ac224f8c6b9b5d572d18abe8b1a4f99.jpg" alt="http://www.thisiscolossal.com/2013/01/a-wooden-domino-tree-by-qiu-zhijie/" /></div><br/>
                    </nobr><br/>
                    <br/>
                    <b>UPD</b>: <a href="http://habrahabr.ru/post/190474/">s01e02</a><br/>
                    <br/>
                    <a name="habracut"></a><br/>
                    <br/>
                    <ol>
                    <li>Стек </li>
                    <li><a href="#Queue">Очередь</a> </li>
                    <li><a href="#Tree">Дерево</a> </li>
                    </ol><br/>
                    <br/>
                    <h4>Стек</h4><br/>
                    Стек, обычно, описывают как некий набор объектов, который сгруппирован вместе, где каждый элемент общего набора идет друг за другом — стопка книг или же подносы, сложенные между собой. В информатике же, стек — это набор объектов, имеющий общее правило образования: последний объект, помещенный в стек, извлекается первым из общего списка. Такое правило еще называют «Последний вошел, первый вышел» или <abbr title="Last In, First Out">LIFO</abbr>. Есть и обратное правило — первый вошел, первый вышел (<abbr title="First In, First Out">FIFO</abbr>), но об этом чуть позже.<br/>
                    Данное правило, LIFO, используется, например, в автоматах по продаже сигарет, конфет — последний загруженный туда объект будет выдан первым.<br/>
                    <br/>
                    Абстрактное определение стека — список, все операции для которого определены относительно одного конца, т.е. вершина стека.<br/>
                    Базовые операции, определяющие стек:<br/>
                    <br/>
                    <ul>
                    <li>init – создать стек.</li>
                    <li>push – добавить элемент в начало (верх) стека, сдвинув остальные на 1 позицию вниз.</li>
                    <li>pop – извлечь (и удалить) элемент из стека (из вершины).</li>
                    <li>top – получить значение на первый элемент стека (не удаляя).</li>
                    <li>isEmpty – проверка стека на пустоту.</li>
                    </ul><br/>
                    <br/>
                    Также можно определить стек с максимально возможным количеством элементов, но это уже мелочи. Однако когда стек больше не может принимать элементы, то стек является переполненным и он возвращает сообщение об этом (stack overflow). Ну и обратная ситуация — изъятие элемента из пустого стека (stack underflow).<br/>
                    <br/>
                    Зная то, что наш стек определен как LIFO и его базовые операции, мы можем написать наш стек через массив, тем более что мы уже имеем для это базовые операции push и pop. Наш пример будет таким:<br/>
                    <br/>
                    <pre><code class="php">&lt;?php
                    class ReadingList
                    {
                        protected $stack;
                        protected $limit;
                        
                        public function __construct($limit = 10) {
                            // инициализация стека
                            $this-&gt;stack = array();
                            // устанавливаем ограничение на количество элементов в стеке
                            $this-&gt;limit = $limit;
                        }
                    
                        public function push($item) {
                            // проверяем, не полон ли наш стек
                            if (count($this-&gt;stack) &lt; $this-&gt;limit) {
                                // добавляем новый элемент в начало массива
                                array_unshift($this-&gt;stack, $item);
                            } else {
                                throw new RunTimeException('Стек переполнен!'); 
                            }
                        }
                    
                        public function pop() {
                            if ($this-&gt;isEmpty()) {
                                // проверка на пустоту стека
                              throw new RunTimeException('Стек пуст!');
                          } else {
                                // Извлекаем первый элемент массива
                                return array_shift($this-&gt;stack);
                            }
                        }
                    
                        public function top() {
                            return current($this-&gt;stack);
                        }
                    
                        public function isEmpty() {
                            return empty($this-&gt;stack);
                        }
                    }
                    </code></pre><br/>
                    <br/>
                    В этом примере мы использовали функции PHP array_unshift() и array_shift() вместо array_push() and array_pop(), поэтому у нас первый элемент стека всегда будет сверху, иначе у нас вершиной был бы n-ый элемент стека. Особой разницы нет. Теперь добавим несколько элементов в наш стек:<br/>
                    <br/>
                    <pre><code class="php">&lt;?php
                    $myBooks = new ReadingList();
                    
                    $myBooks-&gt;push('A Dream of Spring');
                    $myBooks-&gt;push('The Winds of Winter');
                    $myBooks-&gt;push('A Dance with Dragons');
                    $myBooks-&gt;push('A Feast for Crows');
                    $myBooks-&gt;push('A Storm of Swords'); 
                    $myBooks-&gt;push('A Clash of Kings');
                    $myBooks-&gt;push('A Game of Thrones');
                    </code></pre><br/>
                    <br/>
                    А теперь извлечем несколько элементов из него:<br/>
                    <br/>
                    <pre><code class="php">&lt;?php
                    echo $myBooks-&gt;pop(); // Получили и удалили 'A Game of Thrones'
                    echo $myBooks-&gt;pop(); // Получили и удалили 'A Clash of Kings'
                    echo $myBooks-&gt;pop(); // Получили и удалили 'A Storm of Swords'
                    </code></pre><br/>
                    <br/>
                    Что у нас теперь является вершиной стека?<br/>
                    <br/>
                    <pre><code class="php">&lt;?php
                    echo $myBooks-&gt;top(); // Получили 'A Feast for Crows'
                    </code></pre><br/>
                    <br/>
                    Если снова вызвать метод pop(), то «A Feast for Crows» будет удален из стека. Если же сделать push, а затем сразу pop, то стек не изменится, поскольку наш стек работает на основе «последний зашел, первый вышел». Если продолжать вытаскивать элементы из стека, то рано или поздно мы получим исключение с сообщением о том, что стек пуст.<br/>
                    <br/>
                    <h5>SPLStack</h5><br/>
                    PHP (Расширение SPL) предоставляет нам реализации разных структур данных, включая SplStack, начиная с версии 5.3. Мы можем создать наш ReadingList просто унаследовав его:<br/>
                    <br/>
                    <pre><code class="php">&lt;?php
                    class ReadingList extends SplStack
                    {
                    }
                    </code></pre><br/>
                    <br/>
                    SplStack дает нам чуть больше методов, чем мы определили ранее, потому как SplStack реализует двусвязный список, у которого есть емкость (количество элементов в стеке) для реализации перебора.<br/>
                    <br/>
                    Связанный список, являющийся по сути другой абстрактной структурой, это список из узлов, каждый из которых имеет указатель на следующий объект. Данную структуру можно представить таким образом, с однонаправленным перебором:<br/>
                    <br/>
                    <nobr><div style="text-align:center;"><img src="http://habrastorage.org/getpro/habr/post_images/2e5/152/3b2/2e51523b2a3149e8f25f6334349d85e9.png" alt="Это изображение, К.О." /></div></nobr><br/>
                    <br/>
                    В двусвязном же списке, каждый узел имеет два указателя — на предыдущий и следующий узлы в списке. Такая структура позволяет производить перебор в двух направлениях:<br/>
                    <br/>
                    <nobr><div style="text-align:center;"><img src="http://habrastorage.org/getpro/habr/post_images/a94/463/f16/a94463f163f98a6dc3b3b826017023e8.png" alt="Это изображение, К.О." /></div></nobr><br/>
                    <br/>
                    Перебирая элементы, мы должны знать где у нас заканчивается весь список — для этого служат те самые элементы, перечеркнутые внутри.<br/>
                    <br/>
                    <h4>Очередь<a name="Queue"></a></h4><br/>
                    Вот мы и подошли к «первый вошел, первый вышел» или же FIFO. Любой, кто стоял в реальной очереди — знает, что тот, кто занял место первым, первым из нее и уйдет. <s>Исключение — объекты, которым только подписать, спросить, etc.</s><br/>
                    <br/>
                    Базовые операции для очередей такие:<br/>
                    <br/>
                    <ul>
                    <li>init – создать очередь.</li>
                    <li>enqueue – добавить элемент в конец (хвост) очереди.</li>
                    <li>dequeue – удалить элемент из начала очереди (голова).</li>
                    <li>isEmpty – проверка очереди на пустоту.</li>
                    </ul><br/>
                    <br/>
                    <i>P.S Для тех кто знаком с Прологом — в данном случае хвост не содержит в себе все элементы списка, за исключением головы.</i><br/>
                    <br/>
                    PHP также предоставляет нам класс SplQueue (двусвязный список), только в данном случае голова списка — последний элемент. Определим наш ReadingList как очередь:<br/>
                    <br/>
                    <pre><code class="php">&lt;?php
                    class ReadingList extends SplQueue
                    {
                    }
                    
                    $myBooks = new ReadingList();
                    
                    // добавим несколько элементов в нашу очередь
                    $myBooks-&gt;enqueue('A Game of Thrones');
                    $myBooks-&gt;enqueue('A Clash of Kings');
                    $myBooks-&gt;enqueue('A Storm of Swords');
                    </code></pre><br/>
                    <br/>
                    SplQueue наследуется от SplDoublyLinkedList и реализует интерфейс доступа как к массиву, таким образом позволяя обращаться к нашим очередям и стекам через массивы:<br/>
                    <br/>
                    <pre><code class="php">&lt;?php
                    $myBooks[] = 'A Feast of Crows';
                    $myBooks[] = 'A Dance with Dragons';
                    </code></pre><br/>
                    <br/>
                    Удалим пару элементов из очереди:<br/>
                    <br/>
                    <pre><code class="php">&lt;?php
                    echo $myBooks-&gt;dequeue() . &quot;\n&quot;; // Выводит и удаляет 'A Game of Thrones'
                    echo $myBooks-&gt;dequeue() . &quot;\n&quot;; // Выводит и удаляет 'A Clash of Kings'
                    </code></pre><br/>
                    <br/>
                    enqueue() это псевдонимом для push(), однако <b>dequeue() не является псевдонимом для pop()</b>! У pop() другое поведение в контексте очереди, так как если мы воспользуемся pop(), то это удалит элемент из хвоста очереди (A Dance with Dragons), поскольку в очереди главным является правило FIFO.<br/>
                    <br/>
                    Посмотреть (не удаляя) какой элемент является головой списка можно через метод bottom():<br/>
                    <br/>
                    <pre><code class="php">&lt;?php
                    echo $myBooks-&gt;bottom() . &quot;\n&quot;; // Выводит 'A Storm of Swords'
                    </code></pre><br/>
                    <br/>
                    <h4>Деревья<a name="Tree"></a></h4><br/>
                    Управление ADT обычно сводится к 3 операциям: вставка элементов в вструктуру, удаление и получение значения элемента из структуры. В отношении стека и очередей, данные операции зависимы от позиции (xIFO). Но что если нам нужно получить информацию по значению?<br/>
                    <br/>
                    Представим, что у нас есть такая табличка (порядок элементов значения не имеет):<br/>
                    <br/>
                    <nobr><div style="text-align:center;"><img src="http://habrastorage.org/getpro/habr/post_images/37d/87f/24a/37d87f24acc27051f85dc4bcc8d3471a.png" alt="Это изображение, К.О." /></div></nobr><br/>
                    <br/>
                    Очевидно, что стек или очередь нам не помогут в данном случае, поскольку придется обойти все значения, если нужное нам находится в конце или отсутствует вообще. Предположим, что нужный элемент есть в списке. Тогда для его поиска нам придется пройтись, в среднем, по n/2 элементам, где n — длина всего списка. Больше список — больше занимаемого времени на обход. Для решения данной проблемы поиска нужно как-то расположить данные так, чтобы поиск по структуре упростился. И вот здесь появляются деревья.<br/>
                    <br/>
                    Абстрактный пример данной структуры — таблица со следующими операциями:<br/>
                    <br/>
                    <ul>
                    <li>create – создать пустую таблицу. </li>
                    <li>insert – добавить элемент в таблицу. </li>
                    <li>delete – удалить элемент из таблицы. </li>
                    <li>retrieve – найти элемент в таблице.</li>
                    </ul><br/>
                    <br/>
                    Да, это похоже на всем известный <abbr title="Create, Read, Update, Delete">CRUD</abbr> (Создание чтение обновление удаление) из баз данных, потому что деревья и базы данных тесно связаны между собой.<br/>
                    <br/>
                    Один из путей представления нашей таблицы — линейно, т.е. описать её построчно. Такая запись может быть сортирована, быть последовательной (т.е. записи с ограниченной длиной или разной длиной, с разделителями) или связанной (используя указатели на данные). Такое представление имели ранние базы данных и файловые системы (FAT, например). Однако у последовательной записи есть минус — она плоха для вставок и удаления данных, в то время как связанная позволяет динамически выделять место под новые данные. Также, последовательная запись с фиксированной длиной менее эффективна, чем связанная. Поэтому для бинарного дерева поиска лучше выбрать связанную запись.<br/>
                    <br/>
                    Деревья как раз и есть реализация нелинейного поиска, они дают более эффективные возможности двух типов — последовательной и связанной, поддерживают все табличные операции. Поэтому многие современные базы данных используют именно деревья (MyISAM использует деревья для индексов).<br/>
                    <br/>
                    <nobr><div style="text-align:center;"><img src="http://habrastorage.org/getpro/habr/post_images/3ee/918/2dd/3ee9182ddd4b01d271e4111cfc2ddb78.png" alt="Это изображение, К.О." /></div></nobr><br/>
                    <br/>
                    Как видно из этой картинки — деревья это иерархическая структура, где между узлами есть связь родитель → потомок. Узел без потомков — концевой узел (лист), потомок без родителя — корень дерева, связи между узлами — ребра. Узел с двумя потомками — простейшее дерево и основываясь на этом, мы можем представить дерево в виде рекурсивного списка таких узлов. Стоит отметить, что дерево по своей структуре напоминает двусвязный список.<br/>
                    <br/>
                    Поэтому наше дерево можно описать следующим образом:<br/>
                    <br/>
                    <pre><code class="php">&lt;?php
                    class BinaryNode
                    {
                        public $value;    // значение узла
                        public $left;     // левый потомок типа BinaryNode
                        public $right;     // правый потомок типа BinaryNode
                    
                        public function __construct($item) {
                            $this-&gt;value = $item;
                            // новые потомки - вершина
                            $this-&gt;left = null;
                            $this-&gt;right = null;
                        }
                    }
                    
                    class BinaryTree
                    {
                        protected $root; // корень дерева
                    
                        public function __construct() {
                            $this-&gt;root = null;
                        }
                    
                        public function isEmpty() {
                            return $this-&gt;root === null;
                        }
                    }
                    </code></pre><br/>
                    <br/>
                    <h5>Вставка новых значений</h5><br/>
                    Вставка новых значений уже куда более интересная тема. Есть несколько решений данной проблемы, основанных на вращении и балансировки дерева, и для разных задач можно использовать разные реализации деревьев, такие как красное-черное, АВЛ или Б деревья, имеющие разные показатели производительности в операциях вставки, удаления и обхода дерева.<br/>
                    <br/>
                    Для простоты обозначим некоторые правила простейшей реализации: все, что меньше текущего значения — идет влево, больше — вправо.<br/>
                    Повторы будут исключены:<br/>
                    <br/>
                    <ol>
                    <li>Если дерево пустое — вставим [новый_узел] как корень дерева (очевидно же!)</li>
                    <li>пока (дерево не пустое):<br/>
                    <ul>
                    <li> 2a. Если ([текущий узел] пуст) — вставить сюда и остановиться;</li>
                    <li> 2b. Если ([новый_узел] &gt; [текущий узел]) — пробуем вставить [новый_узел] справа и повторим шаг 2</li>
                    <li> 2c. Если ([новый_узел] &lt; [текущий узел]) — пробуем вставить [новый_узел] слева и повторим шаг 2</li>
                    <li> 2d. Иначе значение уже в дереве</li>
                    </ul><br/>
                    </li>
                    </ol><br/>
                    <pre><code class="php">&lt;?php
                    class BinaryTree
                    {
                    ...
                        public function insert($item) {
                            $node = new BinaryNode($item);
                            if ($this-&gt;isEmpty()) {
                                // правило 1
                                $this-&gt;root = $node;
                            }
                            else {
                                // правило 1
                                $this-&gt;insertNode($node, $this-&gt;root);
                            }
                        }
                      
                        protected function insertNode($node, &$subtree) {
                            if ($subtree === null) {
                                // правило 2
                                $subtree = $node;
                            }
                            else {
                                if ($node-&gt;value &gt; $subtree-&gt;value) {
                                    // правило 2b
                                    $this-&gt;insertNode($node, $subtree-&gt;right);
                                }
                                else if ($node-&gt;value &lt; $subtree-&gt;value) {
                                    // правило 2c
                                    $this-&gt;insertNode($node, $subtree-&gt;left);
                                }
                                else {
                                    // исключаем повторы, правило 2d
                                }
                            }
                        }
                    }
                    </code></pre><br/>
                    <br/>
                    Удаление узлов — совсем другая история и затрагиваться не будет. Возможно, как-нибудь в другой раз.<br/>
                    <br/>
                    <h5>Обход дерева</h5><br/>
                    Вспомним как мы начинали с корня и проходили дерево, узел за узлом, чтобы найти пустой узел. Есть 4 главных стратегии обхода дерева:<br/>
                    <br/>
                    <ul>
                    <li>pre-order (прямой порядок)– обработка текущего узла, а затем переход к левому и правому.</li>
                    <li>in-order (симметричная) – сначала проход левой стороны, обработка текущего узла и обход правой стороны.</li>
                    <li>post-order (обратный порядок) – обход левой и правой стороны, затем обработка текущего значения.</li>
                    <li>level-order (в ширину) – обработка текущего значения, затем обработка потомков и переход на следующий уровень.</li>
                    </ul><br/>
                    <br/>
                    Первые три стратегии известны как обход в глубину, который начинается с корня дерева (ну или узла, обозначенного как узел) и проход максимально глубоко по дереву, как это возможно, перед тем как вернуться обратно. Каждая из этих стратегий используется в разных целях. Прямой порядок, например, используется при вставке новых узлов (наш случай) или копировании поддерева, обратный — наоборот, при удалении узлов из дерева.<br/>
                    <br/>
                    Чтобы понять как работает симметричный проход нужно немного изменить наш пример:<br/>
                    <br/>
                    <pre><code class="php">&lt;?php
                    class BinaryNode
                    {
                    ...
                        // сделаем симметричный проход текущего узла
                        public function dump() {
                            if ($this-&gt;left !== null) {
                                $this-&gt;left-&gt;dump();
                            }
                            var_dump($this-&gt;value);
                            if ($this-&gt;right !== null) {
                                $this-&gt;right-&gt;dump();
                            }
                        }
                    }
                    
                    class BinaryTree
                    {
                    ...
                        public function traverse() {
                            // отображение дерева в возрастающем порядке от корня
                            $this-&gt;root-&gt;dump();
                        }
                    }
                    </code></pre><br/>
                    <br/>
                    <h4>Заключение</h4><br/>
                    <br/>
                    Благодарю всех дочитавших до заключения, еще немного текста и картинки :)<br/>
                    <br/>
                    Стоит отметить, что реализации <a href="http://www.php.net/manual/en/class.splstack.php">SplStack</a>, <a href="http://www.php.net/manual/en/class.splqueue.php">SplQueue</a> и <a href="http://www.php.net/manual/en/class.spldoublylinkedlist.php">двусвязного списка</a> не освещены полностью. В документации PHP по ним спрятано довольно много методов, в том числе подсчет количества элементов или использование структуры в качестве итератора.<br/>
                    <br/>
                    Также стоит обратить внимание на <a href="http://habrahabr.ru/post/161987/">данную статью</a> от  <a href="http://habrahabr.ru/users/kpuzuc/" class="user_link">kpuzuc</a><br/>
                    Визуализацию этих структур, ссылки на которые можно найти в <a href="http://habrahabr.ru/post/118554/">посте</a> от  <a href="http://habrahabr.ru/users/tangro/" class="user_link">tangro</a><br/>
                    <br/>
                    Бенчмарки производительности реализаций данных структур скопипастил <a href="http://matthewturland.com/2010/05/20/new-spl-features-in-php-5-3/">отсюда</a><br/>
                    <div class="spoiler"><b class="spoiler_title">взглянуть</b><div class="spoiler_text"><nobr><img src="http://habrastorage.org/getpro/habr/post_images/130/134/541/13013454184889c8367fb9d601a8acdd.png" alt="image"/> </nobr><nobr><img src="http://habrastorage.org/getpro/habr/post_images/f0a/d4c/c56/f0ad4cc560758ed260a1eb4012941db7.png" alt="image"/><br/>
                    </nobr><br/>
                    <br/>
                    <nobr><img src="http://habrastorage.org/getpro/habr/post_images/6a8/1d1/d13/6a81d1d13e86aef4bcb6529793c116a9.png" alt="image"/> </nobr><nobr><img src="http://habrastorage.org/getpro/habr/post_images/6a0/1d1/32c/6a01d132c1c215050beef55fe4d71c85.png" alt="image"/><br/>
                    </nobr><br/>
                    <br/>
                    <nobr><img src="http://habrastorage.org/getpro/habr/post_images/076/885/24e/07688524e094033aebb045f0fffc823b.png" alt="image"/> </nobr><nobr><img src="http://habrastorage.org/getpro/habr/post_images/876/7c8/1c9/8767c81c9b82a10c581523b0b7de46d5.png" alt="image"/><br/>
                    </nobr><br/>
                    </div></div><br/>
                    Что касается очереди, то выбор в пользу SPL довольно очевиден. Реализация стека не особо выигрывает у массива, а двусвязный список так и вовсе проигрывает массивам по количеству операций в секунду. Я, если честно, не вникал в тесты и самому хотелось бы узнать с чем это связано, но скорее всего с тем, что слишком много тянется из «смежных» интерфейсов,
	        </div>
  </div>
 </body>
</html>